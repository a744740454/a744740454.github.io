<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SadnessPineapple</title>
  
  
  <link href="https://a744740454.github.io/atom.xml" rel="self"/>
  
  <link href="https://a744740454.github.io/"/>
  <updated>2021-10-24T13:06:20.862Z</updated>
  <id>https://a744740454.github.io/</id>
  
  <author>
    <name>Sadness Pineapple</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux常用目录</title>
    <link href="https://a744740454.github.io/2021/10/24/linux/linux%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95/"/>
    <id>https://a744740454.github.io/2021/10/24/linux/linux%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95/</id>
    <published>2021-10-24T10:22:06.691Z</published>
    <updated>2021-10-24T13:06:20.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux常用目录"><a href="#linux常用目录" class="headerlink" title="linux常用目录"></a>linux常用目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.应用程序</span><br><span class="line">&#x2F;usr&#x2F;bin:系统用于程序开发的工具，像常用的命令cd等都在这个目录下</span><br><span class="line">&#x2F;usr&#x2F;local 、&#x2F;opt:后期用户添加的命令一般都在这边</span><br><span class="line"></span><br><span class="line">2.头文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;linux常用目录&quot;&gt;&lt;a href=&quot;#linux常用目录&quot; class=&quot;headerlink&quot; title=&quot;linux常用目录&quot;&gt;&lt;/a&gt;linux常用目录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="linux" scheme="https://a744740454.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://a744740454.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分层模型与协议、参考模型</title>
    <link href="https://a744740454.github.io/2021/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E3%80%81%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <id>https://a744740454.github.io/2021/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E3%80%81%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-09-17T14:52:24.681Z</published>
    <updated>2021-09-17T15:40:44.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分层模型与协议、参考模型"><a href="#分层模型与协议、参考模型" class="headerlink" title="分层模型与协议、参考模型"></a>分层模型与协议、参考模型</h2><h3 id="协议的定义"><a href="#协议的定义" class="headerlink" title="协议的定义"></a>协议的定义</h3><p>协议:简单的说就是规则，协议创建出来的目的是为了沟通的方所创建的。打个比方，我这边使用python写了一部分接口，别人如果要调用我的接口应该怎么办呢？如果我不和他说，那他就基本不可能知道我接口的构成。但是我写了接口文档之后，他就知道去如何调用我的接口了，协议的本质其实和接口文档也是类似的。他本质就是不同计算机之间沟通的桥梁。</p><h3 id="协议模型与参考模型"><a href="#协议模型与参考模型" class="headerlink" title="协议模型与参考模型"></a>协议模型与参考模型</h3><p>首先说结论，协议模型的本质是为了让人们使用更好的使用协议，而参考模型则是基于协议模型发展而来的。因此可以这么说协议模型，就是现实中实现某种协议而现实存在的，便于人们理解的。参考模型则不同，参考模型是为了让人们去理解网络的功能与过程去实现的。</p><p>打个比方:TCP/IP协议模型就详细的描述了每个部分实现的功能，是一种事实上的标准</p><p>参考模型:osi7层模型，他并没有详细的解释每一层中的某个协议具体的功能，而是大概的解释了网络的传输功能，并依据功能对此进行分类</p><h3 id="osi7层模型"><a href="#osi7层模型" class="headerlink" title="osi7层模型"></a>osi7层模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.osi7层模型是在1979年ISO公布的系统互连参考模型，他提供了关于网络通信过程的简要描述</span><br><span class="line">2.osi是一种分层的体系结构，共有7层</span><br><span class="line">    应表会传网数物</span><br><span class="line">    应用层:为终端用户提供应用程序服务</span><br><span class="line">    表示层:为应用提供数据的表示形式。例如表示层告诉应用层哪里有加密或者是否为一张图片</span><br><span class="line">    会话层:用户之间管理会话</span><br><span class="line">    传输层:定义数据段并编号，传送数据，并在目的地重组数据</span><br><span class="line">    网络层:为能通过在其他网络的中间设备进行端到端的发送建立编址包</span><br><span class="line">    数据链路层:为在局域网上主机到主机或广域网的设备间的发送建立和编址帧</span><br><span class="line">    物理层:传输数据</span><br><span class="line">3.每一层中都存在着一部分的实体,也就是具体的功能</span><br><span class="line">4.每一层的沟通方式使用的是SAP，也就是接口组成，上下层不需要知道其实现的细节</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分层模型与协议、参考模型&quot;&gt;&lt;a href=&quot;#分层模型与协议、参考模型&quot; class=&quot;headerlink&quot; title=&quot;分层模型与协议、参考模型&quot;&gt;&lt;/a&gt;分层模型与协议、参考模型&lt;/h2&gt;&lt;h3 id=&quot;协议的定义&quot;&gt;&lt;a href=&quot;#协议的定义&quot; c</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://a744740454.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://a744740454.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络的功能特性</title>
    <link href="https://a744740454.github.io/2021/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/"/>
    <id>https://a744740454.github.io/2021/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7/</id>
    <published>2021-09-08T15:17:15.326Z</published>
    <updated>2021-09-15T15:56:07.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的功能特性"><a href="#计算机网络的功能特性" class="headerlink" title="计算机网络的功能特性"></a>计算机网络的功能特性</h2><p>首先我们抛出一个问题:计算机网络如何在两个端用户之间提供访问通信?</p><p>对于上述问题，我们可以简单的用下面这种文字链式的方式来进行回答</p><p><strong>应用–&gt;编码器–&gt;传输介质–&gt;编码器–&gt;应用</strong></p><p>上面是大概的轮廓，现在我们来详细讲讲通信之间的具体方式</p><h3 id="传输数据必备的前提"><a href="#传输数据必备的前提" class="headerlink" title="传输数据必备的前提"></a>传输数据必备的前提</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.众所周知，计算机之间的通信是通过电信号去通信的，那么问题来了，电信号是如何传播的。在当前社会其实是有两种方式的，一种是通过地面的有形介质，也就是深埋在地底的各种线路，一种是无形的介质，也就是卫星。</span><br><span class="line">2.其次我们假设一种情况，一匹马从北京到上海马不停蹄，是不是会累死？电信号其实本质也是这样，电信号在传播的时候其实是会有一定的损失的，如果距离过远，损失会更大，因此我们需要我们的“驿站”，也就是途中的部分转发节点</span><br><span class="line">3.不知道大家小时候知不知道“猫”，小时候如果要上网，那必须使用的方式是拨号上网。其实那是在和电话线使用同一个传输的通道，而猫的作用就是将我们电脑的数字信号转成模拟信号，以达到让电脑的数据可以通过电话的通道去进行传输。</span><br><span class="line"></span><br><span class="line">ps:数字信号和模拟信号的区别</span><br><span class="line">模拟信号是连续的，不停的，是一段电压</span><br><span class="line">数字信号则是通过0和1的数字串所构成的数字流来传输的、</span><br></pre></td></tr></table></figure><h3 id="数据传输的特点"><a href="#数据传输的特点" class="headerlink" title="数据传输的特点"></a>数据传输的特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据传输其实是有一个很明显的特点的，打个比方，我们在打电话的时候，很明显数据应该是持续的，毕竟沟通嘛，不可能你隔一段时间说一句那个隔一段时间说一句，但是数据传输不一样。他其实是一个数据包一个数据包传输，并且每一个数据包之间的传输会有一定的间隔。</span><br><span class="line">综合上述特点，我们可以考虑到计算机之间的通信我们需要有一个比较合理的架构，毕竟世界上不止有两台计算机在通信，是非常多的计算机在进行通信。但是很多计算机其实是用的同一个信道。所以如何去规划这些数据包的传输是一件很有学问的事情</span><br></pre></td></tr></table></figure><h3 id="数据包的传输规划"><a href="#数据包的传输规划" class="headerlink" title="数据包的传输规划"></a>数据包的传输规划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">针对数字信号的传输，设计者是设计了两种方案去解决这个问题</span><br><span class="line">1.报文交换</span><br><span class="line">2.分组交换(现在常用)</span><br><span class="line"></span><br><span class="line">上述两种听名字很高大上，实际上是非常简单的一个概念，报文交换就是将所有的数据一并进行传输，分组交换则是将一整组的数据进行拆分，拆成小的部分进行传输。</span><br><span class="line">至于两者之间的优劣可以去看这个博客:https:&#x2F;&#x2F;blog.csdn.net&#x2F;suxiaorui&#x2F;article&#x2F;details&#x2F;87099192个人觉得是讲解的比较简单详细的。</span><br><span class="line">这里说个结论，分组交换要优于报文交换。因为将数据进行拆分以后，你可以通过多个路线去进行传输，理论上是可以达到类似并行的效果的，并且个人觉得，这样做可以减少丢包带来的损失，就算丢了其中一部分包，你也只需要传输丢失的一部分包即可，不需要进行全部重传的操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多路复用简单的说就是让多个计算机使用同一条通信的信道，这就是多路复用。</span><br><span class="line">多路复用+分组交换是现在最常用的一种传输数据的手段</span><br></pre></td></tr></table></figure><p><img src="C:\Users\QAQ\Desktop\R-C.png" alt="R-C"></p><p>​                                                                                                多路复用图示详解</p><h3 id="分组交换所需要的必备条件-分组的控制信息"><a href="#分组交换所需要的必备条件-分组的控制信息" class="headerlink" title="分组交换所需要的必备条件(分组的控制信息)"></a>分组交换所需要的必备条件(分组的控制信息)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">为了满足上述的功能条件，有下面三点是必须做到的</span><br><span class="line">1.差错控制</span><br><span class="line">2.寻址功能</span><br><span class="line">3.仲裁过程</span><br><span class="line">首先我们来谈谈差错控制，差错控制简单的说就是如何去校验你传输过来的数据是否正确？是否中途被人调过包获少包，你需要有这个校验功能</span><br><span class="line">寻址功能就是我们如何确定要给谁去传这个包？也就是类似的邮件寄件地址</span><br><span class="line">仲裁过程就是在多个计算机同时发包，那么谁先谁后？</span><br><span class="line"></span><br><span class="line">对于上述的功能，我们有个统一的名称(数据链路控制功能) Data Link Control</span><br><span class="line"></span><br><span class="line">上述几点是最重要的，但是除了上述几点，我们还需要考虑下面几点</span><br><span class="line">网络通信量过多了如何？如何确定计算机网络之间的通信已经结束？</span><br><span class="line">对于上述这两个问题也有一定的功能区解决</span><br><span class="line">流量控制以及拥塞控制是去解决第一个问题的。</span><br><span class="line">对于第二个问题则是牵扯到tcp中四次握手三次挥手的概念</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机网络的功能特性&quot;&gt;&lt;a href=&quot;#计算机网络的功能特性&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的功能特性&quot;&gt;&lt;/a&gt;计算机网络的功能特性&lt;/h2&gt;&lt;p&gt;首先我们抛出一个问题:计算机网络如何在两个端用户之间提供访问通信?&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://a744740454.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://a744740454.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像发布</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%20%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%20%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83/</id>
    <published>2021-08-15T15:32:16.623Z</published>
    <updated>2021-08-15T15:32:17.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-镜像发布"><a href="#docker-镜像发布" class="headerlink" title="docker 镜像发布"></a>docker 镜像发布</h2><h3 id="发布到阿里云"><a href="#发布到阿里云" class="headerlink" title="发布到阿里云"></a>发布到阿里云</h3><p>1.登录</p><p>2.选择容器镜像服务</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150257.png" alt="image-20210615150257481"></p><p>3.选择个人版</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150336.png" alt="image-20210615150336052"></p><p>4.创建命名空间</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150356.png" alt="image-20210615150356943"></p><p>5.创建镜像仓库</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150422.png" alt="image-20210615150422024"></p><p>6.根据阿里官方的文档进行镜像的推送即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-镜像发布&quot;&gt;&lt;a href=&quot;#docker-镜像发布&quot; class=&quot;headerlink&quot; title=&quot;docker 镜像发布&quot;&gt;&lt;/a&gt;docker 镜像发布&lt;/h2&gt;&lt;h3 id=&quot;发布到阿里云&quot;&gt;&lt;a href=&quot;#发布到阿里云&quot; cla</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器互联</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/</id>
    <published>2021-08-15T15:32:16.504Z</published>
    <updated>2021-08-15T15:32:17.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-容器互联"><a href="#docker-容器互联" class="headerlink" title="docker 容器互联"></a>docker 容器互联</h2><p>当你创建了多个容器后，你可以直接使用ip地址ping通，但是我们需要考虑一个情况</p><p>某个容器修改了ip,这样子的话其余连接该容器的容器都需要更换成新的ip地址。是不是很麻烦</p><p>这种时候我们需要一种技术，通过连接主机名，也就是容器名，我们就可以让容器之间互相连接。</p><h3 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动容器的时候直接添加--link参数</span><br><span class="line">docker run --link 容器名    </span><br><span class="line">ps:本质是在启动容器内的&#x2F;etc&#x2F;host下添加了映射</span><br></pre></td></tr></table></figure><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker network ls <span class="comment">#查看网络信息</span></span><br><span class="line">docker network inspect 网络名 <span class="comment"># 查看网络详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line">docker network create --driver 模式 --subnet 子网 --gateway 网关 网络名称</span><br><span class="line">eg:</span><br><span class="line">docker network create --driver bridge --subnet <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> --gateway <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> mynet</span><br><span class="line">    </span><br><span class="line"><span class="comment">#容器使用自己的网络创建容器</span></span><br><span class="line">docker run --net 网络名</span><br><span class="line">eg:</span><br><span class="line">    docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line"></span><br><span class="line">使用自定义网络之后在同一网段下我们可以直接使用容器名就可以实现容器互联</span><br></pre></td></tr></table></figure><h3 id="不同网段的容器互相连通"><a href="#不同网段的容器互相连通" class="headerlink" title="不同网段的容器互相连通"></a>不同网段的容器互相连通</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network connect 网络名 容器名</span><br><span class="line">eg:</span><br><span class="line">docker network connect mynet dea17f8117e0</span><br><span class="line">我们可以使用命令查看对应的网络信息</span><br><span class="line">docker network inspect mynet <span class="comment">#查看mynet地下的容器信息</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\CSIT-04\AppData\Roaming\Typora\typora-user-images\image-20210617191824008.png" alt="image-20210617191824008"></p><p>如上图所示，我们将对应的容器直接加入到了对应的网络地下</p><p>这样子我们就做到了不同网段联通的情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-容器互联&quot;&gt;&lt;a href=&quot;#docker-容器互联&quot; class=&quot;headerlink&quot; title=&quot;docker 容器互联&quot;&gt;&lt;/a&gt;docker 容器互联&lt;/h2&gt;&lt;p&gt;当你创建了多个容器后，你可以直接使用ip地址ping通，但是我们需要</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器基础操作</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-15T15:32:16.442Z</published>
    <updated>2021-08-15T15:32:16.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-容器基础操作"><a href="#docker-容器基础操作" class="headerlink" title="docker 容器基础操作"></a>docker 容器基础操作</h2><h3 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a>容器创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run [option] image [cmd]</span><br><span class="line">option:</span><br><span class="line">-d:以守护进程方式运行</span><br><span class="line">-p:指定映射端口  本机端口:r</span><br><span class="line">-P:随机映射端口</span><br><span class="line">-i:保持标准输入打开</span><br><span class="line">-t:分配一个伪终端</span><br><span class="line">-v:设置挂载文件到主机上</span><br><span class="line">--rm:当容器关闭时自动删除</span><br><span class="line">--name:为启动的容器设置一个名字</span><br><span class="line">--network:指定使用哪个网络</span><br><span class="line">-e:设置容器中的环境变量</span><br><span class="line">--link:链接到另一个容器</span><br><span class="line">-h:指定容器内的主机名</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [option]</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND        CREATED             STATUS       PORTS        NAMES</span><br><span class="line">容器id          镜像名     命令            创建时间             状态          端口号        容器名称    </span><br><span class="line"></span><br><span class="line">option:</span><br><span class="line">-a:全部容器，包括停止的</span><br></pre></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker终止容器是首先向容器发送SIGTERM信号,等待一段时间超时后(默认10秒)，再发送SIGKILL信号来终止容器。</span><br><span class="line">docker stop [container id]&#x2F;[names]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach [container id]&#x2F;[names]</span><br><span class="line">attach是最早docker官方推出的进入容器的命令了，不过使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作，当所有窗口退出时，容器结束</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker exec [options] [container id]&#x2F;[names] [command]</span><br><span class="line">既attach之后，exec是官方推出的有一个新的进入容器的命令，这个命令相当于在容器中执行一个命令。</span><br><span class="line">options:</span><br><span class="line">    -d :分离模式: 在后台运行</span><br><span class="line">    -i :即使没有附加也保持STDIN 打开</span><br><span class="line">    -t :分配一个伪终端</span><br><span class="line">eg:</span><br><span class="line">docker exec -it 2f9f406173da &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="nsenter"><a href="#nsenter" class="headerlink" title="nsenter"></a>nsenter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">是一个轻量级的软件，我们可以使用这个软件进入容器之中，一般配合docker inspect使用</span><br><span class="line"></span><br><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; [container id]&#x2F;[names] 获取容器的pid</span><br><span class="line">nsenter</span><br><span class="line">-t, --target pid：指定被进入命名空间的目标进程的pid</span><br><span class="line">-m, --mount[&#x3D;file]：进入mount命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-u, --uts[&#x3D;file]：进入uts命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-i, --ipc[&#x3D;file]：进入ipc命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-n, --net[&#x3D;file]：进入net命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-p, --pid[&#x3D;file]：进入pid命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-U, --user[&#x3D;file]：进入user命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-G, --setgid gid：设置运行程序的gid</span><br><span class="line">-S, --setuid uid：设置运行程序的uid</span><br><span class="line">-r, --root[&#x3D;directory]：设置根目录</span><br><span class="line">-w, --wd[&#x3D;directory]：设置工作目录</span><br></pre></td></tr></table></figure><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在生产环境中排除了使用 docker attach 命令进入容器之后，相信大家第一个想到的就是 ssh。在镜像（或容器） 中安装 SSH Server，这样就能保证多人进入容器且相互之间不受干扰了，相信大家在当前的生产环境中（没有 使用 Docker 的情况）也是这样做的。但是使用了 Docker 容器之后不建议使用 ssh 进入到 Docker 容器内。</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm [options] [container id]&#x2F;[name]</span><br><span class="line">options</span><br><span class="line">-f:强制删除</span><br></pre></td></tr></table></figure><h3 id="容器的文件复制"><a href="#容器的文件复制" class="headerlink" title="容器的文件复制"></a>容器的文件复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将容器内的文件复制出来</span><br><span class="line">docker cp [container id]&#x2F;name:容器内路径 本地路径</span><br><span class="line"></span><br><span class="line">将宿主机的文件复制到容器中</span><br><span class="line">docker cp 本地路径 [container id]&#x2F;name:容器内路径</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-容器基础操作&quot;&gt;&lt;a href=&quot;#docker-容器基础操作&quot; class=&quot;headerlink&quot; title=&quot;docker 容器基础操作&quot;&gt;&lt;/a&gt;docker 容器基础操作&lt;/h2&gt;&lt;h3 id=&quot;容器创建&quot;&gt;&lt;a href=&quot;#容器创建&quot;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
    <category term="docker容器" scheme="https://a744740454.github.io/tags/docker%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>dockerfile</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/Dockerfile/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/Dockerfile/</id>
    <published>2021-08-15T15:32:16.315Z</published>
    <updated>2021-08-15T15:32:16.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile-构建镜像"><a href="#Dockerfile-构建镜像" class="headerlink" title="Dockerfile 构建镜像"></a>Dockerfile <strong>构建镜像</strong></h2><p>​    Dockerfile 由一行行命令语句组成， 并且支持以＃开头的注释行。一般而言， Dockerfile 主体内容分为四 部分：基础镜像信息、 维护者信息、 镜像操作指令和容器启动时执行指令。 </p><p>​    Docker 以从上到下的顺序运行 Dockerfile 的指令。为了指定基本映像，第一条指令必须是 FROM。一个声明以＃字符开头则被视为注释。可以在 Docker 文件中使用 RUN，CMD，FROM，EXPOSE，ENV 等指令</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210422191053.png" alt="image-20210422191046184"></p><h3 id="FROM-基础镜像"><a href="#FROM-基础镜像" class="headerlink" title="FROM:基础镜像"></a>FROM:基础镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">FROM image</span><br><span class="line">FROM image:tag</span><br><span class="line">FROM image@digest</span><br><span class="line">eg:</span><br><span class="line">FROM mysql:5.6</span><br><span class="line">ps: tag或digest是可选的，如果不使用这两个值，会使用latest版本的基础镜像 </span><br></pre></td></tr></table></figure><h3 id="MAINTAINER-维护者信息"><a href="#MAINTAINER-维护者信息" class="headerlink" title="MAINTAINER:维护者信息"></a>MAINTAINER:维护者信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">MAINTAINER name</span><br><span class="line">eg:</span><br><span class="line">MAINTAINER SadnessPineapple</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN 用于在镜像容器中执行命令，有以下两种命令执行方式</span><br><span class="line">格式:</span><br><span class="line">run command</span><br><span class="line">eg:</span><br><span class="line">RUN [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]<span class="comment">#executable:可执行的命令</span></span><br><span class="line">run echo <span class="string">&quot;nameserver 114.114.114.114&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将本地文件添加到容器中(tar类型的文件会自动解压)</span><br><span class="line">格式:</span><br><span class="line">ADD src dest</span><br><span class="line">eg:</span><br><span class="line">ADD hom* &#x2F;mydir&#x2F; 将所有的文件添加到&#x2F;mydir&#x2F;下</span><br></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</span><br><span class="line">格式:</span><br><span class="line">COPY src dest</span><br><span class="line">eg:</span><br><span class="line">dest 为镜像中的绝对路径或者相对于WORKDIR的路径</span><br></pre></td></tr></table></figure><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构建容器后调用，也就是在容器启动时才进行调用，只能有一个，多个的话会被覆盖</span><br><span class="line">格式:</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">示例:</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能与CMD相似，但是不会被覆盖</span><br><span class="line">格式:</span><br><span class="line">ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">示例:</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用于为镜像添加元数据</span><br><span class="line">格式:</span><br><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt;</span><br><span class="line">示例:</span><br><span class="line">LABEL version&#x3D;&quot;1.0&quot; description&#x3D;&quot;这是一个 Web 服务器&quot; by&#x3D;&quot;IT 笔录&quot;</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量</span><br><span class="line">格式:</span><br><span class="line">ENV &lt;key&gt; &lt;value&gt; <span class="comment">#&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置 一个变量</span></span><br><span class="line">示例:</span><br><span class="line">    ENV myName John Doe</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定于外界交互的端口</span><br><span class="line">格式:</span><br><span class="line">EXPOSE &lt;port&gt;</span><br><span class="line">示例:</span><br><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Docker的数据持久化主要有两种方式：</span><br><span class="line">    bind mount</span><br><span class="line">    volume</span><br><span class="line">Docker的数据持久化即使数据不随着container的结束而结束，数据存在于host机器上——要么存在于host的某个指定目录中（使用bind mount），要么使用docker自己管理的volume（/var/lib/docker/volumes下）。</span><br><span class="line">格式:</span><br><span class="line">VOLUME [<span class="string">&quot;/path&quot;</span>] <span class="comment">#将容器内的某个文件挂载出来</span></span><br><span class="line">示例:</span><br><span class="line">VOLUME [<span class="string">&quot;/data&quot;</span>]</span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的。</span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">工作目录，类似于 cd 命令</span><br><span class="line">格式:</span><br><span class="line">WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">WORKDIR /a (这时工作目录为/a) </span><br><span class="line">WORKDIR b (这时工作目录为/a/b)</span><br><span class="line">ps：通过 WORKDIR 设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。在使用 docker run运行容器时，可以通过-w 参数覆盖构建时所设置的工作目录。</span><br></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">用于指定传递给构建运行时的变量</span><br><span class="line">构建参数和ENV的效果一样,都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history还是可以看到所有值的。</span><br><span class="line">Dockerfile中的ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build中用--build-arg&lt;参数名&gt;=&lt;值&gt;来覆盖。</span><br><span class="line">灵活的使用ARG指令，能够在不修改Dockerfile的情况下，构建出不同的镜像。</span><br><span class="line">ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于FROM指令中</span><br><span class="line"></span><br><span class="line">格式:</span><br><span class="line">ARG参数名=默认值</span><br><span class="line">eg:</span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式： </span><br><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line">eg:</span><br><span class="line">    ONBUILD ADD . &#x2F;app&#x2F;src </span><br><span class="line">    ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build --dir &#x2F;app&#x2F;src </span><br><span class="line"></span><br><span class="line">ps:当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发</span><br></pre></td></tr></table></figure><h3 id="使用dockerfile启动"><a href="#使用dockerfile启动" class="headerlink" title="使用dockerfile启动"></a>使用dockerfile启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在Dockerfile文件这个目录下执行命令</span><br><span class="line">docker build -t myubuntu:v1 .</span><br><span class="line">docker：docker命令。</span><br><span class="line"></span><br><span class="line">build：编译。</span><br><span class="line"></span><br><span class="line">-t：镜像的名字及tag，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个tag，参考docker build命令详解。</span><br><span class="line"></span><br><span class="line">myubuntu：生成镜像的名称。</span><br><span class="line"></span><br><span class="line">v1：生成镜像的版本号。</span><br><span class="line"></span><br><span class="line">.：点符号“.”代表当前</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c_id</span><br><span class="line">from_clue&#x3D;&quot;&quot;,</span><br><span class="line">up_regno&#x3D;&quot;&quot;,</span><br><span class="line">regno&#x3D;&quot;&quot;,                       </span><br><span class="line">file &#x3D; False,</span><br><span class="line">report &#x3D; False, </span><br><span class="line">release &#x3D; &quot;判断&quot;, </span><br><span class="line">remand &#x3D; False,</span><br><span class="line">write&#x3D;True,</span><br><span class="line">delete&#x3D;True,</span><br><span class="line">finish&#x3D;True</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dockerfile-构建镜像&quot;&gt;&lt;a href=&quot;#Dockerfile-构建镜像&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile 构建镜像&quot;&gt;&lt;/a&gt;Dockerfile &lt;strong&gt;构建镜像&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;​</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker安装教程</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E5%AE%89%E8%A3%85/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E5%AE%89%E8%A3%85/</id>
    <published>2021-08-15T15:32:16.249Z</published>
    <updated>2021-08-15T15:32:16.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker安装教程-centos"><a href="#docker安装教程-centos" class="headerlink" title="docker安装教程(centos)"></a>docker安装教程(centos)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>更换yum源</span><br><span class="line"><span class="comment">#里面找到你需要更换的系统版本，根据教程即可</span></span><br><span class="line">https://developer.aliyun.com/mirror/</span><br><span class="line">yum clean <span class="built_in">all</span> <span class="comment">#清除缓存</span></span><br><span class="line">yum makecache <span class="comment">#生成缓存</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>更新系统</span><br><span class="line">yum update -y --exclud=kernel*</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>安装所需的基础软件</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-<span class="number">7.</span>repo</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>将docker-ce的源换成国内阿里的</span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">ps:上述命令找不到的话先使用安装一些工具包 yum -y install yum-utils</span><br><span class="line">yum makecache fast <span class="comment">#更新缓存</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5.</span>安装docker-ce</span><br><span class="line">yum -y install docker-ce <span class="comment">#docker社区版</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>设置开机自启动并且立即启动程序</span><br><span class="line">systemctl enable --now docker </span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>检验是否启动成功</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="docker安装教程-Ubuntu"><a href="#docker安装教程-Ubuntu" class="headerlink" title="docker安装教程(Ubuntu)"></a>docker安装教程(Ubuntu)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>更新系统</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>安装基础软件</span><br><span class="line">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>安装GPG证书</span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - OK</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>写入软件源信息</span><br><span class="line">add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>更新</span><br><span class="line">apt-get -y update</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>安装docker-ce</span><br><span class="line">apt-get -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>启动</span><br><span class="line">Docker Engine - Community</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># CentOS-Base.repo</span><br><span class="line">#</span><br><span class="line"># The mirror system uses the connecting IP address of the client and the</span><br><span class="line"># update status of each mirror to pick mirrors that are updated to and</span><br><span class="line"># geographically close to the client.  You should use this for CentOS updates</span><br><span class="line"># unless you are manually picking other mirrors.</span><br><span class="line">#</span><br><span class="line"># If the mirrorlist&#x3D; does not work for you, as a fall back you can try the</span><br><span class="line"># remarked out baseurl&#x3D; line instead.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name&#x3D;CentOS-$releasever - Base</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;os</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#released updates</span><br><span class="line">[updates]</span><br><span class="line">name&#x3D;CentOS-$releasever - Updates</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;updates&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;updates</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name&#x3D;CentOS-$releasever - Extras</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;extras&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;extras</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name&#x3D;CentOS-$releasever - Plus</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;centosplus&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;centosplus</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker安装教程-centos&quot;&gt;&lt;a href=&quot;#docker安装教程-centos&quot; class=&quot;headerlink&quot; title=&quot;docker安装教程(centos)&quot;&gt;&lt;/a&gt;docker安装教程(centos)&lt;/h2&gt;&lt;figure cla</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简介</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E7%AE%80%E4%BB%8B/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E7%AE%80%E4%BB%8B/</id>
    <published>2021-08-15T15:32:16.123Z</published>
    <updated>2021-08-15T15:32:16.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h2><h3 id="docker历史简述"><a href="#docker历史简述" class="headerlink" title="docker历史简述"></a>docker历史简述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在2010年得时候，几个年轻人凑到一块开了一个公司。公司名字是dotcloud.这个公司得主要技术点就是linux得容器技术，为了方便管理这些容器。该公司内部开开发得内部工具名字就是docker。</span><br><span class="line">但是由于该公司开始得时候业务并不是很景气，但是他们又不想放弃该技术。因此他们选择在2013年将docker开源。也因此越来越多得人开始使用docker。然后发现docker得好用之处，docker也因此变得红火起来</span><br></pre></td></tr></table></figure><h3 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h3><p>docker是用go语言进行得开发，然后使用得技术是容器化。</p><p>在docker之前我们使用得技术一般是虚拟机技术</p><h3 id="容器化技术与虚拟机技术得区别"><a href="#容器化技术与虚拟机技术得区别" class="headerlink" title="容器化技术与虚拟机技术得区别"></a>容器化技术与虚拟机技术得区别</h3><p>虚拟机技术</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210602195328.jpg" alt="1622634522(1)"></p><p>容器化技术</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210602200910.jpg" alt="1622635727(1)"></p><p>由上面两图可以得知容器化技术相较于虚拟化技术，使用得是同一个计算机得内核，也正因为如此，容器化技术与虚拟机技术相比而言会小很多</p><h3 id="docker优点"><a href="#docker优点" class="headerlink" title="docker优点"></a>docker优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.应用更快速得交付和部署</span><br><span class="line">打包镜像发布测试，一键运行</span><br><span class="line">2.更便捷得升级和扩缩容</span><br><span class="line">项目打包为一个镜像，扩展 服务器a</span><br><span class="line">3.更简单得系统运维</span><br><span class="line">容器化之后，开发，测试环境高度一致</span><br><span class="line">4.更高效得计算资源利用</span><br><span class="line">是内核级别得虚拟化，可以在一个物理机上运行很多得容器实例</span><br></pre></td></tr></table></figure><h3 id="docker各个项目地址"><a href="#docker各个项目地址" class="headerlink" title="docker各个项目地址"></a>docker各个项目地址</h3><p>docker社区地址:<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>docker官网地址:<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>docker文档地址:<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker简介&quot;&gt;&lt;a href=&quot;#docker简介&quot; class=&quot;headerlink&quot; title=&quot;docker简介&quot;&gt;&lt;/a&gt;docker简介&lt;/h2&gt;&lt;h3 id=&quot;docker历史简述&quot;&gt;&lt;a href=&quot;#docker历史简述&quot; class=&quot;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像基础操作</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-15T15:32:16.027Z</published>
    <updated>2021-08-15T15:32:16.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker镜像基础操作"><a href="#docker镜像基础操作" class="headerlink" title="docker镜像基础操作"></a>docker镜像基础操作</h2><h3 id="镜像获取"><a href="#镜像获取" class="headerlink" title="镜像获取"></a>镜像获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">镜像获取</span><br><span class="line">docker pull [image_name][:image_version]</span><br><span class="line">eg:</span><br><span class="line">docker pull nginx:1.17</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看本地主机上已有的镜像的基本信息</span></span><br><span class="line">docker images</span><br><span class="line">docker images ls</span><br><span class="line">REPOSITORY   TAG     IMAGE ID      CREATED      SIZE</span><br><span class="line">镜像来源     镜像标签     镜像<span class="built_in">id</span>      镜像创建时间   镜像大小</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">-a:列出所有(包括临时文件)镜像文件</span><br><span class="line">-q:仅显示 ID 信息</span><br><span class="line">--digests=true|false：列出镜像的数字摘要值</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像详细信息，可以看到作者、id等</span></span><br><span class="line">docker inspect [REPOSITORY]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像历史,若构建信息过长，可以使用--no-trunc来输出完整信息</span></span><br><span class="line">docker history [REPOSITORY]</span><br></pre></td></tr></table></figure><h3 id="镜像添加tag"><a href="#镜像添加tag" class="headerlink" title="镜像添加tag"></a>镜像添加tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">镜像添加tag</span><br><span class="line">docker tag redis:latest myredis:latest</span><br><span class="line"></span><br><span class="line">REPOSITORY   TAG     IMAGE ID       CREATED        SIZE </span><br><span class="line">redis        latest  74d107221092   19 hours ago   104MB</span><br></pre></td></tr></table></figure><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker search [option] keyword</span><br><span class="line">option:</span><br><span class="line">-f:过滤输出内容 <span class="keyword">is</span>-official=true/false stars=<span class="number">800</span>(收藏数超过<span class="number">8000</span>)</span><br><span class="line">--limit:限制<span class="number">3</span>条</span><br><span class="line">--no-trunc:不截断输出结果,有些输出结果过长的话会被截断，添加这个可以看到完整的信息</span><br><span class="line"></span><br><span class="line">输出参数释义</span><br><span class="line">NAME         DESCRIPTION    STARS    OFFICIAL    AUTOMATED</span><br><span class="line">镜像名称       镜像描述        点赞数    是否是官方    自动构建</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [option] [name]</span><br><span class="line">docker image rm [option] [name]</span><br><span class="line">参数:</span><br><span class="line">-f:强制</span><br><span class="line"></span><br><span class="line">docker image prune [option] <span class="comment">#清理镜像</span></span><br><span class="line">-a:删除所有不用的镜像，不加的话是删除临时镜像</span><br><span class="line">-f:强制删除，没有提示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>构建镜像的方式有三种，基于容器导入、基于本地模板导入、基于dockerfile创建</p><h4 id="基于容器导入（commit）"><a href="#基于容器导入（commit）" class="headerlink" title="基于容器导入（commit）"></a>基于容器导入（commit）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit [option] [container id] [image:tag]</span><br><span class="line">eg:docker commit -m &quot;Add a file&quot; -a &quot;Alvin&quot; 820a17fe3935 centos:v1</span><br><span class="line">option:</span><br><span class="line">-a:作者信息</span><br><span class="line">-m:提交信息</span><br><span class="line">-p:提交时，暂停容器运行</span><br><span class="line"></span><br><span class="line">执行命令后会在本地生成一个基于原先容器的镜像</span><br></pre></td></tr></table></figure><h4 id="将容器导出并保存为镜像-export"><a href="#将容器导出并保存为镜像-export" class="headerlink" title="将容器导出并保存为镜像(export)"></a>将容器导出并保存为镜像(export)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker export [container id] &gt; file</span><br><span class="line">eg:</span><br><span class="line">docker export daf9c3656be3 &gt; nginx.tar</span><br><span class="line"></span><br><span class="line">ps:使用export命令导出的是个压缩包，且只保存容器当时的状态</span><br></pre></td></tr></table></figure><h4 id="从包中读取镜像-import"><a href="#从包中读取镜像-import" class="headerlink" title="从包中读取镜像(import)"></a>从包中读取镜像(import)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对应export的读取</span><br><span class="line">docker import file image:tag</span><br><span class="line">eg:</span><br><span class="line">docker import nginx.tar nginx:v1</span><br></pre></td></tr></table></figure><h4 id="将本地的镜像保存为镜像包-save"><a href="#将本地的镜像保存为镜像包-save" class="headerlink" title="将本地的镜像保存为镜像包(save)"></a>将本地的镜像保存为镜像包(save)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker save [REPOSITORY]&#x2F;[image_id] &gt; file</span><br><span class="line">eg:</span><br><span class="line">    docker save nginx &gt; nginx.tar</span><br><span class="line">    docker save 62d49f9bab67 &gt; nginx.tar</span><br><span class="line">    </span><br><span class="line">将本地的多个镜像保存为镜像包</span><br><span class="line">docker save [image] [image] &gt; file</span><br><span class="line">docker save -o file [image] [image]</span><br></pre></td></tr></table></figure><h4 id="从包中加载镜像-load"><a href="#从包中加载镜像-load" class="headerlink" title="从包中加载镜像(load)"></a>从包中加载镜像(load)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对应save的读取</span><br><span class="line">docker load &lt; file</span><br></pre></td></tr></table></figure><h4 id="save与export区别"><a href="#save与export区别" class="headerlink" title="save与export区别"></a>save与export区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export导出的是容器打包</span><br><span class="line">save 是将镜像打包成包</span><br><span class="line"></span><br><span class="line">export因为是保存的容器当时的状态，因此体积会小于save,相应的会丢失到容器的元数据和以前的历史记录</span><br><span class="line">save会完整的保存</span><br><span class="line"></span><br><span class="line">export 不能将多个容器打包</span><br><span class="line">save 可以将多个包打包</span><br><span class="line"></span><br><span class="line">export 一般用来制作基础镜像:如我们从一个 ubuntu 镜像启动一个容器，然后安 装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用， 比如作为基础的开发环境</span><br><span class="line"></span><br><span class="line">save 一般用于不能连接外网的情况下，将本地的镜像打包，给别的机器使用</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker镜像基础操作&quot;&gt;&lt;a href=&quot;#docker镜像基础操作&quot; class=&quot;headerlink&quot; title=&quot;docker镜像基础操作&quot;&gt;&lt;/a&gt;docker镜像基础操作&lt;/h2&gt;&lt;h3 id=&quot;镜像获取&quot;&gt;&lt;a href=&quot;#镜像获取&quot; cla</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像加载原理</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-15T15:32:15.999Z</published>
    <updated>2021-08-15T15:32:16.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><h3 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS(联合文件系统)"></a>UnionFS(联合文件系统)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnionFS:Union文件系统是一种分层、轻量级并且高性能得文件系统，它支持对文件系统得修改，作为一次提交来一层层得叠加，同时可以将不同目录挂载到一个虚拟文件系统下，Union文件系统是docker镜像得基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体得应用镜像。</span><br><span class="line">特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终得文件系统会包含所有底层得文件和目录</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker得镜像实际上是由一层一层得文件系统组成，这种层级得文件系统就是UnionFS</span><br><span class="line"></span><br><span class="line">bootfs(boot file system)主要包含bootloader和kernel,bootloader主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统，docker镜像得最底层就是bootfs。这一层与我们典型得linux&#x2F;unix系统是一样得，包含boot加载器和内核。当boot加载完成之后整个内核都在内存中了，此时内存得使用权由bootfs转交给内核，此时系统会卸载bootfs.</span><br><span class="line"></span><br><span class="line">rootfs(root file system),在bootfs之上。包含得就是典型Linux系统中得&#x2F;dev,&#x2F;proc,&#x2F;bin,&#x2F;etc等标准目录和文件。rootfs就是各种不同得操作系统发行版，比如Ubuntu,Centos等。</span><br><span class="line"></span><br><span class="line">docker底层直接使用得是linux得kernel(内核)，因此他的上层只需要封装简单得指令集即可，这也是为什么docker得镜像都比较小，并且启动速度快得原因</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker得镜像都是只读得，当容器启动得时候，一个新的可写层会被加载到镜像得顶部。</span><br><span class="line">这一层就是我们通常说的容器层，容器之下得都叫镜像层</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker镜像加载原理&quot;&gt;&lt;a href=&quot;#docker镜像加载原理&quot; class=&quot;headerlink&quot; title=&quot;docker镜像加载原理&quot;&gt;&lt;/a&gt;docker镜像加载原理&lt;/h2&gt;&lt;h3 id=&quot;UnionFS-联合文件系统&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker可视化工具</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</id>
    <published>2021-08-15T15:32:15.842Z</published>
    <updated>2021-08-15T15:32:16.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker可视化工具"><a href="#docker可视化工具" class="headerlink" title="docker可视化工具"></a>docker可视化工具</h2><p>portainer(先用这个)</p><p>Rancher(CI/CD再用)</p><h3 id="什么是portainer"><a href="#什么是portainer" class="headerlink" title="什么是portainer"></a>什么是portainer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">portainer就是docker得一个可视化工具，通过这个我们可以使用图形化界面去控制docker镜像</span><br><span class="line"></span><br><span class="line">启动命令:</span><br><span class="line">docker run -d -v &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot; -p 8088:9000 portainer&#x2F;portainer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker可视化工具&quot;&gt;&lt;a href=&quot;#docker可视化工具&quot; class=&quot;headerlink&quot; title=&quot;docker可视化工具&quot;&gt;&lt;/a&gt;docker可视化工具&lt;/h2&gt;&lt;p&gt;portainer(先用这个)&lt;/p&gt;
&lt;p&gt;Rancher(CI/</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker网络</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E7%BD%91%E7%BB%9C/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E7%BD%91%E7%BB%9C/</id>
    <published>2021-08-15T15:32:15.788Z</published>
    <updated>2021-08-15T15:32:16.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><p>我们每启动一个docker容器，docker就会给容器分配一个ip,我们只要安装了docker.就会有一个网卡docker0桥接模式，使用的技术是veth-pair技术</p><h3 id="什么是veth-pair"><a href="#什么是veth-pair" class="headerlink" title="什么是veth-pair"></a>什么是veth-pair</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">veth-pair（Virtual Ethernet）就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span><br><span class="line">正因为有这个特性 veth-pair 充当一个桥梁</span><br></pre></td></tr></table></figure><h3 id="docker容器网络原理图示"><a href="#docker容器网络原理图示" class="headerlink" title="docker容器网络原理图示"></a>docker容器网络原理图示</h3><p><img src="C:\Users\CSIT-04\AppData\Roaming\Typora\typora-user-images\image-20210617172700073.png" alt="image-20210617172700073"></p><p>ps:docker所有得网络都是虚拟得，虚拟得转发效率高</p><h3 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a>docker网络类型</h3><table><thead><tr><th>docker网络模型</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>host模式</td><td>–network=host</td><td>容器和宿主机共享一个网络空间(Network namespace)</td></tr><tr><td>contain模式</td><td>–network=container:ID</td><td>容器和另外一个容器共享Network namespace</td></tr><tr><td>none模式</td><td>–network=none</td><td>容器有独立的Network namespace,但是并没有进行任何的网络设置</td></tr><tr><td>bridge模式</td><td>–network=bridge</td><td>当docker进程启动，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的docker容器都会链接到这个虚拟网桥上，这也是默认的模式</td></tr></tbody></table><h3 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果启动容器的时候使用 host模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</span><br><span class="line"> 使用host模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可以使用宿主机的 端口，不需要进行 NAT，host 最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</span><br></pre></td></tr></table></figure><h3 id="contain模式"><a href="#contain模式" class="headerlink" title="contain模式"></a>contain模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信</span><br></pre></td></tr></table></figure><h3 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</span><br><span class="line">这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过--network&#x3D;none 来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</span><br></pre></td></tr></table></figure><h3 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</span><br><span class="line">从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</span><br><span class="line">bridge模式是docker的默认网络模式，不写--net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用 iptables -t nat -vnL查看。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker网络&quot;&gt;&lt;a href=&quot;#docker网络&quot; class=&quot;headerlink&quot; title=&quot;docker网络&quot;&gt;&lt;/a&gt;docker网络&lt;/h2&gt;&lt;p&gt;我们每启动一个docker容器，docker就会给容器分配一个ip,我们只要安装了docke</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器数据卷</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</id>
    <published>2021-08-15T15:32:15.702Z</published>
    <updated>2021-08-15T15:32:16.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>首先我们思考一个场景，你有一个容器，里面装得是mysql,然后你一不小心将这个容器删除了。那么容器中得数据还在吗？</p><p>毫无疑问，这数据就没了。而为了解决这个问题。将数据持久化保存，我们可以了解docker得一个新知识点。卷技术，也就是目录得挂载。</p><p>这个技术可以帮助我们将容器内得目录，挂载到linux上面。保证数据得持久化，并且实现了容器之间得数据共享。</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210610151207.jpg" alt="1623309115(1)"></p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><p>容器使用数据卷得方式进行绑定之后，等于进行了双向绑定，我们可以在外面进行修改操作，容器内部也会修改，同理修改容器内也会影响到容器外</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v 主机内地址:容器内地址</span><br></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><h4 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匿名挂载就是你使用-v挂载路径得时候，只写了容器内得路径，没有写容器外</span><br><span class="line">eg:</span><br><span class="line">docker run -d -P --name nginx01 -v &#x2F;etc&#x2F;nginx nginx</span><br><span class="line"></span><br><span class="line">我们可以使用下述命令查看volume得信息</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect volume 名称</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210610171721.png" alt="image-20210610171721619"></p><h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匿名挂载就是你使用-v挂载路径得时候，写了一个任意得名称</span><br><span class="line">eg:</span><br><span class="line">docker run -d -P --name nginx02 -v test:&#x2F;etc&#x2F;nginx nginx</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210610171731.png" alt="image-20210610171731811"></p><h4 id="如何确定是具名挂载还是匿名挂载"><a href="#如何确定是具名挂载还是匿名挂载" class="headerlink" title="如何确定是具名挂载还是匿名挂载"></a>如何确定是具名挂载还是匿名挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径 匿名挂载</span><br><span class="line">-v 名称:容器内路径 具名挂载</span><br><span class="line">-v &#x2F;路径:容器内路径 指定路径挂载</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ro:readonly <span class="comment">#只读</span></span><br><span class="line">rw:readwrite <span class="comment">#可读可写</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    docker run -d -P --name nginx02 -v test:/etc/nginx:ro nginx <span class="comment">#挂载出来得文件只能由宿主机改，r</span></span><br></pre></td></tr></table></figure><h3 id="容器之间实现数据共享"><a href="#容器之间实现数据共享" class="headerlink" title="容器之间实现数据共享"></a>容器之间实现数据共享</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现在我们有两个容器。然后需要实现两个容器内之间的数据共享。这种时候我们就可以使用下述方法</span><br><span class="line">docker run --volumes-from 主容器</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;容器数据卷&quot;&gt;&lt;a href=&quot;#容器数据卷&quot; class=&quot;headerlink&quot; title=&quot;容器数据卷&quot;&gt;&lt;/a&gt;容器数据卷&lt;/h2&gt;&lt;p&gt;首先我们思考一个场景，你有一个容器，里面装得是mysql,然后你一不小心将这个容器删除了。那么容器中得数据还在吗？&lt;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>alembic使用</title>
    <link href="https://a744740454.github.io/2021/08/15/flask_sqlachemy/alembic%E4%BD%BF%E7%94%A8/"/>
    <id>https://a744740454.github.io/2021/08/15/flask_sqlachemy/alembic%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-15T15:32:14.463Z</published>
    <updated>2021-08-15T15:32:14.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="alembic使用"><a href="#alembic使用" class="headerlink" title="alembic使用"></a>alembic使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask官方对sqlachemy提供了一个类似django的迁移工具，这个迁移工具的名字就是alembic</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install alembic</span><br></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alembic init 仓库名</span><br></pre></td></tr></table></figure><h3 id="修改对应文件"><a href="#修改对应文件" class="headerlink" title="修改对应文件"></a>修改对应文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根路径下alembic.ini</span><br><span class="line">找到下面那行并修改为你对应数据库的url</span><br><span class="line">url：sqlalchemy.url = mysql+pymysql://root:admin@localhost/alembic_demo</span><br><span class="line"></span><br><span class="line">项目下env.py</span><br><span class="line">找到下面这行,修改为你models.py中的 sqlachemy.metadata</span><br><span class="line">target_metadata = <span class="literal">None</span></span><br><span class="line">eg:</span><br><span class="line">    <span class="keyword">from</span> animation.db.models <span class="keyword">import</span> db</span><br><span class="line">    target_metadata = db.metadata</span><br></pre></td></tr></table></figure><h3 id="进行数据迁移"><a href="#进行数据迁移" class="headerlink" title="进行数据迁移"></a>进行数据迁移</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成迁移文件</span></span><br><span class="line">alembic revision -m <span class="string">&quot;first commit&quot;</span>  <span class="comment"># -m为message</span></span><br><span class="line"><span class="comment">#进行迁移</span></span><br><span class="line">alembic upgrade head</span><br></pre></td></tr></table></figure><h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alembic downgrade 版本号</span><br><span class="line"></span><br><span class="line"><span class="comment">#版本号查看命令</span></span><br><span class="line">alembic history</span><br></pre></td></tr></table></figure><h3 id="数据库对应操作"><a href="#数据库对应操作" class="headerlink" title="数据库对应操作"></a>数据库对应操作</h3><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op.create_table(</span><br><span class="line">    &quot;table_name&quot;,  # 表名</span><br><span class="line">    sa.Column(&#x27;column_name1&#x27;, sa.Integer, primary_key=True, autoincrement=True, nullable=False),</span><br><span class="line">    sa.Column(&#x27;column_name2&#x27;, sa.Integer, nullable=False),</span><br><span class="line">    sa.Column(&#x27;column_name3&#x27;, sa.DATETIME, nullable=False),</span><br><span class="line">    sa.Column(&#x27;column_name4&#x27;, sa.Float, nullable=False)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>数据类型：sa.DATETIME, sa.Integer, sa.Float, sa.String(45), sa.String(255)等</p><h4 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op.drop_table(&#x27;table_name&#x27;)</span><br></pre></td></tr></table></figure><h4 id="修改某一列的属性"><a href="#修改某一列的属性" class="headerlink" title="修改某一列的属性"></a>修改某一列的属性</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op.alter_column(</span><br><span class="line">    table_name=&#x27;table_name&#x27;,</span><br><span class="line">    column_name=&#x27;old_column_name&#x27;,</span><br><span class="line">    new_column_name=&#x27;new_column_name&#x27;,</span><br><span class="line">    type_=sa.String(255),</span><br><span class="line">    existing_type=sa.DATETIME, nullable=False</span><br><span class="line">) </span><br></pre></td></tr></table></figure><h4 id="加一列"><a href="#加一列" class="headerlink" title="加一列"></a>加一列</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">op.add_column(</span><br><span class="line">&#x27;table_name&#x27;,</span><br><span class="line">sa.Column(&#x27;new_column_name&#x27;, sa.String(45), nullable=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op.drop_column(&#x27;table_name&#x27;, &#x27;column_name&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;alembic使用&quot;&gt;&lt;a href=&quot;#alembic使用&quot; class=&quot;headerlink&quot; title=&quot;alembic使用&quot;&gt;&lt;/a&gt;alembic使用&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="flask-sqlalchemy" scheme="https://a744740454.github.io/categories/flask-sqlalchemy/"/>
    
    
    <category term="alembic" scheme="https://a744740454.github.io/tags/alembic/"/>
    
  </entry>
  
  <entry>
    <title>flask-sqlalchemy简单使用</title>
    <link href="https://a744740454.github.io/2021/08/15/flask_sqlachemy/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://a744740454.github.io/2021/08/15/flask_sqlachemy/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-15T15:32:14.294Z</published>
    <updated>2021-08-15T15:32:14.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask-sqlalchemy简单使用"><a href="#flask-sqlalchemy简单使用" class="headerlink" title="flask-sqlalchemy简单使用"></a>flask-sqlalchemy简单使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>安装</span><br><span class="line">pip install flask-sqlalchemy</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>初始化对象</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将flask对象注册进db中</span><br><span class="line">app.config[<span class="string">&quot;SQLALCHEMY_DATABASE_URI&quot;</span>] = <span class="string">&#x27;sqlite:///&#x27;</span> + os.path.join(base_dir, <span class="string">&#x27;data.sqlite&#x27;</span>)</span><br><span class="line">db.init_app(app)</span><br></pre></td></tr></table></figure><h2 id="sqlachemy的配置"><a href="#sqlachemy的配置" class="headerlink" title="sqlachemy的配置"></a>sqlachemy的配置</h2><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SQLALCHEMY_DATABASE_URI</td><td align="left">用于连接的数据库 URI 。例如:sqlite:tmp/test.db 或 mysql://username:password@server/db</td></tr><tr><td align="left">SQLALCHEMY_BINDS</td><td align="left">一个映射 binds 到连接 URI 的字典。更多 binds 的信息见 用 Binds 操作多个数据库 。</td></tr><tr><td align="left">SQLALCHEMY_ECHO</td><td align="left">如果设置为 Ture ， SQLAlchemy 会记录所有 发给 stderr 的语句，这对调试有用。</td></tr><tr><td align="left">SQLALCHEMY_RECORD_QUERIES</td><td align="left">可以用于显式地禁用或启用查询记录。查询记录 在调试或测试模式自动启用。更多信息见 get_debug_queries()</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;flask-sqlalchemy简单使用&quot;&gt;&lt;a href=&quot;#flask-sqlalchemy简单使用&quot; class=&quot;headerlink&quot; title=&quot;flask-sqlalchemy简单使用&quot;&gt;&lt;/a&gt;flask-sqlalchemy简单使用&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="flask-sqlalchemy" scheme="https://a744740454.github.io/categories/flask-sqlalchemy/"/>
    
    
    <category term="flask-sqlalchemy" scheme="https://a744740454.github.io/tags/flask-sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title>uwsgi配置详解</title>
    <link href="https://a744740454.github.io/2021/08/15/uwsgi/uwsgi%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://a744740454.github.io/2021/08/15/uwsgi/uwsgi%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-08-15T15:32:12.721Z</published>
    <updated>2021-08-15T15:32:13.056Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">master &#x3D; true </span><br><span class="line">#启动主进程，来管理其他进程，其它的uwsgi进程都是这个master进程的子进程，如果kill这个master进程，相当于重启所有的uwsgi进程。</span><br><span class="line"></span><br><span class="line">chdir &#x3D; &#x2F;web&#x2F;www&#x2F;mysite </span><br><span class="line">#在app加载前切换到当前目录， 指定运行目录</span><br><span class="line"></span><br><span class="line">module &#x3D; mysite.wsgi </span><br><span class="line"># 加载一个WSGI模块,这里加载mysite&#x2F;wsgi.py这个模块</span><br><span class="line"></span><br><span class="line">py-autoreload&#x3D;1  </span><br><span class="line">#监控python模块mtime来触发重载 (只在开发时使用)</span><br><span class="line"></span><br><span class="line">lazy-apps&#x3D;true  </span><br><span class="line">#在每个worker而不是master中加载应用</span><br><span class="line"></span><br><span class="line">socket &#x3D; &#x2F;test&#x2F;myapp.sock </span><br><span class="line">#指定socket文件，也可以指定为127.0.0.1:9000，这样就会监听到网络套接字</span><br><span class="line"></span><br><span class="line">processes &#x3D; 2 #启动2个工作进程，生成指定数目的worker&#x2F;进程</span><br><span class="line"></span><br><span class="line">buffer-size &#x3D; 32768 </span><br><span class="line">#设置用于uwsgi包解析的内部缓存区大小为64k。默认是4k。</span><br><span class="line"></span><br><span class="line">daemonize &#x3D; &#x2F;var&#x2F;log&#x2F;myapp_uwsgi.log </span><br><span class="line"># 使进程在后台运行，并将日志打到指定的日志文件或者udp服务器</span><br><span class="line"></span><br><span class="line">log-maxsize &#x3D; 5000000 #设置最大日志文件大小</span><br><span class="line"></span><br><span class="line">disable-logging &#x3D; true #禁用请求日志记录</span><br><span class="line"></span><br><span class="line">vacuum &#x3D; true #当服务器退出的时候自动删除unix socket文件和pid文件。</span><br><span class="line"></span><br><span class="line">listen &#x3D; 120 #设置socket的监听队列大小（默认：100）</span><br><span class="line"></span><br><span class="line">pidfile &#x3D; &#x2F;var&#x2F;run&#x2F;uwsgi.pid #指定pid文件</span><br><span class="line"></span><br><span class="line">enable-threads &#x3D; true </span><br><span class="line">#允许用内嵌的语言启动线程。这将允许你在app程序中产生一个子线程</span><br><span class="line"></span><br><span class="line">reload-mercy &#x3D; 8 </span><br><span class="line">#设置在平滑的重启（直到接收到的请求处理完才重启）一个工作子进程中，等待这个工作结束的最长秒数。这个配置会使在平滑地重启工作子进程中，如果工作进程结束时间超过了8秒就会被强行结束（忽略之前已经接收到的请求而直接结束）</span><br><span class="line"></span><br><span class="line">max-requests &#x3D; 5000 </span><br><span class="line">#为每个工作进程设置请求数的上限。当一个工作进程处理的请求数达到这个值，那么该工作进程就会被回收重用（重启）。你可以使用这个选项来默默地对抗内存泄漏</span><br><span class="line"></span><br><span class="line">limit-as &#x3D; 256 </span><br><span class="line">#通过使用POSIX&#x2F;UNIX的setrlimit()函数来限制每个uWSGI进程的虚拟内存使用数。这个配置会限制uWSGI的进程占用虚拟内存不超过256M。如果虚拟内存已经达到256M，并继续申请虚拟内存则会使程序报内存错误，本次的http请求将返回500错误。</span><br><span class="line"></span><br><span class="line">harakiri &#x3D; 60 </span><br><span class="line">#一个请求花费的时间超过了这个harakiri超时时间，那么这个请求都会被丢弃，并且当前处理这个请求的工作进程会被回收再利用（即重启）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="uwsgi" scheme="https://a744740454.github.io/categories/uwsgi/"/>
    
    
    <category term="uwsgi" scheme="https://a744740454.github.io/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>oauth2了解</title>
    <link href="https://a744740454.github.io/2021/08/15/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5/oauth2/"/>
    <id>https://a744740454.github.io/2021/08/15/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5/oauth2/</id>
    <published>2021-08-15T15:32:12.602Z</published>
    <updated>2021-08-15T15:32:13.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="oauth2"><a href="#oauth2" class="headerlink" title="oauth2"></a>oauth2</h2><h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.Third-party application：第三方应用程序，本文中又称&quot;客户端&quot;（client）。</span><br><span class="line"></span><br><span class="line">2.HTTP service：HTTP服务提供商，本文中简称&quot;服务提供商&quot;，即上一节例子中的Google。</span><br><span class="line"></span><br><span class="line">3.Resource Owner：资源所有者，本文中又称&quot;用户&quot;（user）。</span><br><span class="line"></span><br><span class="line">4.User Agent：用户代理，本文中就是指浏览器。</span><br><span class="line"></span><br><span class="line">5.Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。</span><br><span class="line"></span><br><span class="line">6.Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</span><br></pre></td></tr></table></figure><h3 id="oauth2运行流程"><a href="#oauth2运行流程" class="headerlink" title="oauth2运行流程"></a>oauth2运行流程</h3><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210423101339.png" alt="bg2014051203"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（A）用户打开客户端以后，客户端要求用户给予授权。</span><br><span class="line"></span><br><span class="line">（B）用户同意给予客户端授权。</span><br><span class="line"></span><br><span class="line">（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</span><br><span class="line"></span><br><span class="line">（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</span><br><span class="line"></span><br><span class="line">（E）客户端使用令牌，向资源服务器申请获取资源。</span><br><span class="line"></span><br><span class="line">（F）资源服务器确认令牌无误，同意向客户端开放资源。</span><br></pre></td></tr></table></figure><p>而对于上述步骤中b是关键，有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><h3 id="客户端的授权方式"><a href="#客户端的授权方式" class="headerlink" title="客户端的授权方式"></a>客户端的授权方式</h3><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">授权码模式是功能最完整、流程最严密的授权模式。他的特点就是通过客户端的后台服务器，与<span class="string">&quot;服务提供商&quot;</span>的认证服务器进行互动</span><br><span class="line">  </span><br><span class="line">步骤如下:</span><br><span class="line">    A.用户访问客户端，后者将前者导向认证服务器。</span><br><span class="line">    B.用户选择是否给予客户端授权。</span><br><span class="line">    C.假设用户给予授权，认证服务器将用户导向客户端事先指定的<span class="string">&quot;重定向URI&quot;</span>（redirection URI），同时附上一个授权码。</span><br><span class="line">    D.客户端收到授权码，附上早先的<span class="string">&quot;重定向URI&quot;</span>，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</span><br><span class="line">    E.认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="A步骤"><a href="#A步骤" class="headerlink" title="A步骤"></a>A步骤</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A步骤中，客户端申请认证的URI，包含以下参数：</span><br><span class="line">    response_type：表示授权类型，必选项，此处的值固定为&quot;code&quot;</span><br><span class="line">    client_id：表示客户端的ID，必选项</span><br><span class="line">    redirect_uri：表示重定向URI，可选项</span><br><span class="line">    scope：表示申请的权限范围，可选项</span><br><span class="line">    state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值</span><br><span class="line">    </span><br><span class="line">示例:</span><br><span class="line">    GET </span><br><span class="line">    &#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;s6BhdRkqt3&amp;state&#x3D;xyz&amp;redirect_uri&#x3D;https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><h5 id="C步骤"><a href="#C步骤" class="headerlink" title="C步骤"></a>C步骤</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c步骤中，服务器回应客户端的URI，包含以下的参数:</span><br><span class="line">    code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</span><br><span class="line">state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</span><br><span class="line">https:&#x2F;&#x2F;client.example.com&#x2F;cb?code&#x3D;SplxlOBeZQQYbYS6WxSbIA&amp;state&#x3D;xyz</span><br></pre></td></tr></table></figure><h5 id="D步骤"><a href="#D步骤" class="headerlink" title="D步骤"></a>D步骤</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数</span><br><span class="line">    grant_type：表示使用的授权模式，必选项，此处的值固定为&quot;authorization_code&quot;。</span><br><span class="line">    code：表示上一步获得的授权码，必选项。</span><br><span class="line">    redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</span><br><span class="line">    client_id：表示客户端ID，必选项。</span><br><span class="line">  </span><br><span class="line">示例:</span><br><span class="line">    Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">    Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">    grant_type&#x3D;authorization_code&amp;code&#x3D;SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">    &amp;redirect_uri&#x3D;https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="E步骤"><a href="#E步骤" class="headerlink" title="E步骤"></a>E步骤</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">E步骤中，认证服务器发送的HTTP回复，包含以下参数：</span><br><span class="line">    access_token：表示访问令牌，必选项。</span><br><span class="line">    token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</span><br><span class="line">    expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</span><br><span class="line">    refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</span><br><span class="line">    scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</span><br><span class="line">    </span><br><span class="line">示例:</span><br><span class="line">    Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">    Cache-Control: no-store</span><br><span class="line">    Pragma: no-cache</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">      &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">      &quot;expires_in&quot;:3600,</span><br><span class="line">      &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">      &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210423102040.png" alt="bg2014051204"></p><h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>​               </p><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;oauth2&quot;&gt;&lt;a href=&quot;#oauth2&quot; class=&quot;headerlink&quot; title=&quot;oauth2&quot;&gt;&lt;/a&gt;oauth2&lt;/h2&gt;&lt;h3 id=&quot;名词定义&quot;&gt;&lt;a href=&quot;#名词定义&quot; class=&quot;headerlink&quot; title=&quot;名</summary>
      
    
    
    
    <category term="oauth2" scheme="https://a744740454.github.io/categories/oauth2/"/>
    
    
    <category term="第三方" scheme="https://a744740454.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
    <category term="oauth2" scheme="https://a744740454.github.io/tags/oauth2/"/>
    
  </entry>
  
  <entry>
    <title>阿里云oss第三方接入</title>
    <link href="https://a744740454.github.io/2021/08/15/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5/%E9%98%BF%E9%87%8C%E4%BA%91oss/"/>
    <id>https://a744740454.github.io/2021/08/15/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5/%E9%98%BF%E9%87%8C%E4%BA%91oss/</id>
    <published>2021-08-15T15:32:12.497Z</published>
    <updated>2021-08-15T15:32:12.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阿里云oss"><a href="#阿里云oss" class="headerlink" title="阿里云oss"></a>阿里云oss</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> celery_module.utils.logger <span class="keyword">import</span> get_logger</span><br><span class="line"><span class="keyword">from</span> celery_module.config.config <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取logger对象</span></span><br><span class="line">logger = get_logger(<span class="string">&#x27;ali_oss_logger&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建Bucket对象，所有Object相关的接口都可以通过Bucket对象来进行</span></span><br><span class="line">bucket = oss2.Bucket(oss2.Auth(access_key_id, access_key_secret), upload_endpoint, bucket_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认上面的参数都填写正确了</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> (access_key_id, access_key_secret, bucket_name, upload_endpoint):</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> param, <span class="string">&#x27;请设置参数：&#x27;</span> + param</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_local_image_info</span>(<span class="params">image_file</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取本地图片信息</span></span><br><span class="line"><span class="string">    :param str image_file: 本地图片</span></span><br><span class="line"><span class="string">    :return tuple: a 3-tuple(height, width, format).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    im = Image.<span class="built_in">open</span>(image_file)</span><br><span class="line">    <span class="keyword">return</span> im.height, im.width, im.<span class="built_in">format</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_img</span>(<span class="params">ali_oss_path, path, evidence_id, title, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param ali_oss_path: 上传到OSS的文件路径  eg:original/example.png</span></span><br><span class="line"><span class="string">    :param path: 本地图片路径   eg:example.png</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 上传图片</span></span><br><span class="line">    result = bucket.put_object_from_file(ali_oss_path, path, *args, **kwargs)</span><br><span class="line">    record_log(<span class="string">&quot;图片上传&quot;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;code&quot;</span>: result.status, <span class="string">&quot;ali_oss_path&quot;</span>: ali_oss_path, <span class="string">&quot;path&quot;</span>: path, <span class="string">&quot;evidence_id&quot;</span>: evidence_id,</span><br><span class="line">            <span class="string">&#x27;title&#x27;</span>: title&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_info</span>(<span class="params">ali_oss_path, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param ali_oss_path: 阿里oss的图片路径 eg:original/example.png</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return: 返回json加载过后的图片信息</span></span><br><span class="line"><span class="string">        example:&#123;&#x27;FileSize&#x27;: &#123;&#x27;value&#x27;: &#x27;346013&#x27;&#125;, &#x27;Format&#x27;: &#123;&#x27;value&#x27;: &#x27;png&#x27;&#125;, &#x27;ImageHeight&#x27;: &#123;&#x27;value&#x27;: &#x27;4000&#x27;&#125;, &#x27;ImageWidth&#x27;: &#123;&#x27;value&#x27;: &#x27;1920&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    result = bucket.get_object(ali_oss_path, *args, process=<span class="string">&#x27;image/info&#x27;</span>, **kwargs)</span><br><span class="line">    json_content = result.read()</span><br><span class="line">    decoded_json = json.loads(oss2.to_unicode(json_content))</span><br><span class="line">    <span class="keyword">return</span> decoded_json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_img</span>(<span class="params">ali_oss_path</span>):</span></span><br><span class="line">    result = bucket.delete_object(ali_oss_path)</span><br><span class="line">    record_log(<span class="string">&quot;图片删除&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_log</span>(<span class="params">msg, result</span>):</span></span><br><span class="line">    <span class="keyword">if</span> result.status == <span class="number">200</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;<span class="subst">&#123;msg&#125;</span>成功&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.warning(<span class="string">f&quot;<span class="subst">&#123;msg&#125;</span>失败&quot;</span>)</span><br><span class="line">        logger.warning(<span class="string">f&quot;状态码:<span class="subst">&#123;result.status&#125;</span>-----------请求ID:<span class="subst">&#123;result.request_id&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = get_img_info(<span class="string">&#x27;original/syb222.png&#x27;</span>)</span><br><span class="line">    print(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阿里云oss&quot;&gt;&lt;a href=&quot;#阿里云oss&quot; class=&quot;headerlink&quot; title=&quot;阿里云oss&quot;&gt;&lt;/a&gt;阿里云oss&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="第三方" scheme="https://a744740454.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
    
    <category term="第三方" scheme="https://a744740454.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
    <category term="oss" scheme="https://a744740454.github.io/tags/oss/"/>
    
    <category term="阿里云" scheme="https://a744740454.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>集成支付宝作为第三方收款软件</title>
    <link href="https://a744740454.github.io/2021/08/15/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5/%E4%BD%BF%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BD%9C%E4%B8%BA%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    <id>https://a744740454.github.io/2021/08/15/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5/%E4%BD%BF%E7%94%A8%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BD%9C%E4%B8%BA%E7%AC%AC%E4%B8%89%E6%96%B9/</id>
    <published>2021-08-15T15:32:12.419Z</published>
    <updated>2021-08-15T15:32:12.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="支付宝官方文档"><a href="#支付宝官方文档" class="headerlink" title="支付宝官方文档"></a>支付宝官方文档</h2><p>链接:<a href="https://opendocs.alipay.com/open/270/105898/">https://opendocs.alipay.com/open/270/105898/</a></p><h2 id="步骤简介"><a href="#步骤简介" class="headerlink" title="步骤简介"></a>步骤简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.进行实名认证</span><br><span class="line"></span><br><span class="line">2.下载开发助手</span><br><span class="line">链接:https:&#x2F;&#x2F;opendocs.alipay.com&#x2F;open&#x2F;291&#x2F;introduce</span><br><span class="line"></span><br><span class="line">3.利用开发助手生成RSA2应用密钥以及应用公钥</span><br><span class="line"></span><br><span class="line">4.支付宝开放平台--&gt;沙箱环境--&gt;沙箱应用--&gt;RSA2密钥设置--&gt;获得支付宝公钥</span><br><span class="line"></span><br><span class="line">5.下载沙箱版支付宝(测试用)</span><br><span class="line">链接:https:&#x2F;&#x2F;openhome.alipay.com&#x2F;platform&#x2F;appDaily.htm?tab&#x3D;tool</span><br><span class="line"></span><br><span class="line">6.在沙箱环境中的沙箱账号中获得买家账号以及卖家账号</span><br><span class="line">链接:https:&#x2F;&#x2F;openhome.alipay.com&#x2F;platform&#x2F;appDaily.htm?tab&#x3D;account</span><br><span class="line"></span><br><span class="line">7.由于支付宝没有提供python对应的sdk，因此我们使用第三方的支付宝开源框架alipay</span><br><span class="line">git地址:https:&#x2F;&#x2F;github.com&#x2F;fzlee&#x2F;alipay</span><br><span class="line">使用:pip install python-alipay-sdk --upgrade</span><br><span class="line"></span><br><span class="line">8.在自己的应用中进行配置即可</span><br></pre></td></tr></table></figure><h2 id="详细使用教程"><a href="#详细使用教程" class="headerlink" title="详细使用教程"></a>详细使用教程</h2><p>支付宝的调用流程图如下</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p><h3 id="支付宝调用流程"><a href="#支付宝调用流程" class="headerlink" title="支付宝调用流程"></a>支付宝调用流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.前台点击支付按钮</span><br><span class="line">2.往后台发送post请求,后台获得商品等信息</span><br><span class="line">3.使用alipay往支付宝的接口发送请求，携带前端的返回地址以及后端的回调接口地址。</span><br><span class="line">4.获得支付宝的付款页面地址返回给前端</span><br><span class="line">5.前端跳转到支付宝的支付页面接口</span><br><span class="line">6.用户输入账号密码后跳转回原先的商户页面,前台往后台发送一个get请求,返回订单号,可以通过该订单号去查询订单情况</span><br><span class="line">7.支付宝往我们后端接口地址发送一个异步的post请求</span><br><span class="line">8.后端进行数据库修改等操作</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">libs                                    <span class="comment"># 第三方模块都放这个包下</span></span><br><span class="line">    ├── iPay  <span class="comment"># aliapy二次封装包</span></span><br><span class="line">    │   ├── __init__.py <span class="comment"># 包文件</span></span><br><span class="line">    │   ├── pem<span class="comment"># 公钥私钥文件夹</span></span><br><span class="line">    │   │   ├── alipay_public_key.pem<span class="comment"># 支付宝公钥文件</span></span><br><span class="line">    │   │   ├── app_private_key.pem<span class="comment"># 应用私钥文件</span></span><br><span class="line">    │   ├── pay.py<span class="comment"># 支付文件</span></span><br><span class="line">    └── └── settings.py </span><br></pre></td></tr></table></figure><h3 id="alipay-public-key-pem"><a href="#alipay-public-key-pem" class="headerlink" title="alipay_public_key.pem"></a>alipay_public_key.pem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">支付宝公钥</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h3 id="app-private-key-pem"><a href="#app-private-key-pem" class="headerlink" title="app_private_key.pem"></a>app_private_key.pem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">应用私钥</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 应用私钥</span></span><br><span class="line">APP_PRIVATE_KEY_STRING = <span class="built_in">open</span>(os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&#x27;pem&#x27;</span>, <span class="string">&#x27;app_private_key.pem&#x27;</span>)).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付宝公钥</span></span><br><span class="line">ALIPAY_PUBLIC_KEY_STRING = <span class="built_in">open</span>(os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&#x27;pem&#x27;</span>, <span class="string">&#x27;alipay_public_key.pem&#x27;</span>)).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用ID</span></span><br><span class="line">APP_ID = <span class="string">&#x27;2016093000631831&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密方式</span></span><br><span class="line">SIGN = <span class="string">&#x27;RSA2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否是支付宝测试环境(沙箱环境)，如果采用真是支付宝环境，配置False</span></span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付网关</span></span><br><span class="line">GATEWAY = <span class="string">&#x27;https://openapi.alipaydev.com/gateway.do&#x27;</span> <span class="keyword">if</span> DEBUG <span class="keyword">else</span> <span class="string">&#x27;https://openapi.alipay.com/gateway.do&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="pay-py"><a href="#pay-py" class="headerlink" title="pay.py"></a>pay.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> alipay <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付对象</span></span><br><span class="line">alipay = AliPay(</span><br><span class="line">    appid=settings.APP_ID,</span><br><span class="line">    app_notify_url=<span class="literal">None</span>,</span><br><span class="line">    app_private_key_string=settings.APP_PRIVATE_KEY_STRING,</span><br><span class="line">    alipay_public_key_string=settings.ALIPAY_PUBLIC_KEY_STRING,</span><br><span class="line">    sign_type=settings.SIGN,</span><br><span class="line">    debug=settings.DEBUG</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支付网关</span></span><br><span class="line">gateway = settings.GATEWAY</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;支付宝官方文档&quot;&gt;&lt;a href=&quot;#支付宝官方文档&quot; class=&quot;headerlink&quot; title=&quot;支付宝官方文档&quot;&gt;&lt;/a&gt;支付宝官方文档&lt;/h2&gt;&lt;p&gt;链接:&lt;a href=&quot;https://opendocs.alipay.com/open/270/1</summary>
      
    
    
    
    <category term="第三方" scheme="https://a744740454.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
    
    <category term="第三方" scheme="https://a744740454.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
    <category term="支付宝" scheme="https://a744740454.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    
  </entry>
  
</feed>
