<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SadnessPineapple</title>
  
  
  <link href="https://a744740454.github.io/atom.xml" rel="self"/>
  
  <link href="https://a744740454.github.io/"/>
  <updated>2021-08-15T15:32:17.054Z</updated>
  <id>https://a744740454.github.io/</id>
  
  <author>
    <name>Sadness Pineapple</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker镜像发布</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%20%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%20%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83/</id>
    <published>2021-08-15T15:32:16.623Z</published>
    <updated>2021-08-15T15:32:17.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-镜像发布"><a href="#docker-镜像发布" class="headerlink" title="docker 镜像发布"></a>docker 镜像发布</h2><h3 id="发布到阿里云"><a href="#发布到阿里云" class="headerlink" title="发布到阿里云"></a>发布到阿里云</h3><p>1.登录</p><p>2.选择容器镜像服务</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150257.png" alt="image-20210615150257481"></p><p>3.选择个人版</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150336.png" alt="image-20210615150336052"></p><p>4.创建命名空间</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150356.png" alt="image-20210615150356943"></p><p>5.创建镜像仓库</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210615150422.png" alt="image-20210615150422024"></p><p>6.根据阿里官方的文档进行镜像的推送即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-镜像发布&quot;&gt;&lt;a href=&quot;#docker-镜像发布&quot; class=&quot;headerlink&quot; title=&quot;docker 镜像发布&quot;&gt;&lt;/a&gt;docker 镜像发布&lt;/h2&gt;&lt;h3 id=&quot;发布到阿里云&quot;&gt;&lt;a href=&quot;#发布到阿里云&quot; cla</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器互联</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/</id>
    <published>2021-08-15T15:32:16.504Z</published>
    <updated>2021-08-15T15:32:17.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-容器互联"><a href="#docker-容器互联" class="headerlink" title="docker 容器互联"></a>docker 容器互联</h2><p>当你创建了多个容器后，你可以直接使用ip地址ping通，但是我们需要考虑一个情况</p><p>某个容器修改了ip,这样子的话其余连接该容器的容器都需要更换成新的ip地址。是不是很麻烦</p><p>这种时候我们需要一种技术，通过连接主机名，也就是容器名，我们就可以让容器之间互相连接。</p><h3 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动容器的时候直接添加--link参数</span><br><span class="line">docker run --link 容器名    </span><br><span class="line">ps:本质是在启动容器内的&#x2F;etc&#x2F;host下添加了映射</span><br></pre></td></tr></table></figure><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker network ls <span class="comment">#查看网络信息</span></span><br><span class="line">docker network inspect 网络名 <span class="comment"># 查看网络详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line">docker network create --driver 模式 --subnet 子网 --gateway 网关 网络名称</span><br><span class="line">eg:</span><br><span class="line">docker network create --driver bridge --subnet <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> --gateway <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> mynet</span><br><span class="line">    </span><br><span class="line"><span class="comment">#容器使用自己的网络创建容器</span></span><br><span class="line">docker run --net 网络名</span><br><span class="line">eg:</span><br><span class="line">    docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line"></span><br><span class="line">使用自定义网络之后在同一网段下我们可以直接使用容器名就可以实现容器互联</span><br></pre></td></tr></table></figure><h3 id="不同网段的容器互相连通"><a href="#不同网段的容器互相连通" class="headerlink" title="不同网段的容器互相连通"></a>不同网段的容器互相连通</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network connect 网络名 容器名</span><br><span class="line">eg:</span><br><span class="line">docker network connect mynet dea17f8117e0</span><br><span class="line">我们可以使用命令查看对应的网络信息</span><br><span class="line">docker network inspect mynet <span class="comment">#查看mynet地下的容器信息</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\CSIT-04\AppData\Roaming\Typora\typora-user-images\image-20210617191824008.png" alt="image-20210617191824008"></p><p>如上图所示，我们将对应的容器直接加入到了对应的网络地下</p><p>这样子我们就做到了不同网段联通的情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-容器互联&quot;&gt;&lt;a href=&quot;#docker-容器互联&quot; class=&quot;headerlink&quot; title=&quot;docker 容器互联&quot;&gt;&lt;/a&gt;docker 容器互联&lt;/h2&gt;&lt;p&gt;当你创建了多个容器后，你可以直接使用ip地址ping通，但是我们需要</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器基础操作</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%20%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-15T15:32:16.442Z</published>
    <updated>2021-08-15T15:32:16.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-容器基础操作"><a href="#docker-容器基础操作" class="headerlink" title="docker 容器基础操作"></a>docker 容器基础操作</h2><h3 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a>容器创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run [option] image [cmd]</span><br><span class="line">option:</span><br><span class="line">-d:以守护进程方式运行</span><br><span class="line">-p:指定映射端口  本机端口:r</span><br><span class="line">-P:随机映射端口</span><br><span class="line">-i:保持标准输入打开</span><br><span class="line">-t:分配一个伪终端</span><br><span class="line">-v:设置挂载文件到主机上</span><br><span class="line">--rm:当容器关闭时自动删除</span><br><span class="line">--name:为启动的容器设置一个名字</span><br><span class="line">--network:指定使用哪个网络</span><br><span class="line">-e:设置容器中的环境变量</span><br><span class="line">--link:链接到另一个容器</span><br><span class="line">-h:指定容器内的主机名</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [option]</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND        CREATED             STATUS       PORTS        NAMES</span><br><span class="line">容器id          镜像名     命令            创建时间             状态          端口号        容器名称    </span><br><span class="line"></span><br><span class="line">option:</span><br><span class="line">-a:全部容器，包括停止的</span><br></pre></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker终止容器是首先向容器发送SIGTERM信号,等待一段时间超时后(默认10秒)，再发送SIGKILL信号来终止容器。</span><br><span class="line">docker stop [container id]&#x2F;[names]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach [container id]&#x2F;[names]</span><br><span class="line">attach是最早docker官方推出的进入容器的命令了，不过使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作，当所有窗口退出时，容器结束</span><br></pre></td></tr></table></figure><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker exec [options] [container id]&#x2F;[names] [command]</span><br><span class="line">既attach之后，exec是官方推出的有一个新的进入容器的命令，这个命令相当于在容器中执行一个命令。</span><br><span class="line">options:</span><br><span class="line">    -d :分离模式: 在后台运行</span><br><span class="line">    -i :即使没有附加也保持STDIN 打开</span><br><span class="line">    -t :分配一个伪终端</span><br><span class="line">eg:</span><br><span class="line">docker exec -it 2f9f406173da &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="nsenter"><a href="#nsenter" class="headerlink" title="nsenter"></a>nsenter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">是一个轻量级的软件，我们可以使用这个软件进入容器之中，一般配合docker inspect使用</span><br><span class="line"></span><br><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; [container id]&#x2F;[names] 获取容器的pid</span><br><span class="line">nsenter</span><br><span class="line">-t, --target pid：指定被进入命名空间的目标进程的pid</span><br><span class="line">-m, --mount[&#x3D;file]：进入mount命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-u, --uts[&#x3D;file]：进入uts命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-i, --ipc[&#x3D;file]：进入ipc命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-n, --net[&#x3D;file]：进入net命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-p, --pid[&#x3D;file]：进入pid命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-U, --user[&#x3D;file]：进入user命令空间。如果指定了file，则进入file的命令空间</span><br><span class="line">-G, --setgid gid：设置运行程序的gid</span><br><span class="line">-S, --setuid uid：设置运行程序的uid</span><br><span class="line">-r, --root[&#x3D;directory]：设置根目录</span><br><span class="line">-w, --wd[&#x3D;directory]：设置工作目录</span><br></pre></td></tr></table></figure><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在生产环境中排除了使用 docker attach 命令进入容器之后，相信大家第一个想到的就是 ssh。在镜像（或容器） 中安装 SSH Server，这样就能保证多人进入容器且相互之间不受干扰了，相信大家在当前的生产环境中（没有 使用 Docker 的情况）也是这样做的。但是使用了 Docker 容器之后不建议使用 ssh 进入到 Docker 容器内。</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm [options] [container id]&#x2F;[name]</span><br><span class="line">options</span><br><span class="line">-f:强制删除</span><br></pre></td></tr></table></figure><h3 id="容器的文件复制"><a href="#容器的文件复制" class="headerlink" title="容器的文件复制"></a>容器的文件复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将容器内的文件复制出来</span><br><span class="line">docker cp [container id]&#x2F;name:容器内路径 本地路径</span><br><span class="line"></span><br><span class="line">将宿主机的文件复制到容器中</span><br><span class="line">docker cp 本地路径 [container id]&#x2F;name:容器内路径</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-容器基础操作&quot;&gt;&lt;a href=&quot;#docker-容器基础操作&quot; class=&quot;headerlink&quot; title=&quot;docker 容器基础操作&quot;&gt;&lt;/a&gt;docker 容器基础操作&lt;/h2&gt;&lt;h3 id=&quot;容器创建&quot;&gt;&lt;a href=&quot;#容器创建&quot;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
    <category term="docker容器" scheme="https://a744740454.github.io/tags/docker%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>dockerfile</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/Dockerfile/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/Dockerfile/</id>
    <published>2021-08-15T15:32:16.315Z</published>
    <updated>2021-08-15T15:32:16.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile-构建镜像"><a href="#Dockerfile-构建镜像" class="headerlink" title="Dockerfile 构建镜像"></a>Dockerfile <strong>构建镜像</strong></h2><p>​    Dockerfile 由一行行命令语句组成， 并且支持以＃开头的注释行。一般而言， Dockerfile 主体内容分为四 部分：基础镜像信息、 维护者信息、 镜像操作指令和容器启动时执行指令。 </p><p>​    Docker 以从上到下的顺序运行 Dockerfile 的指令。为了指定基本映像，第一条指令必须是 FROM。一个声明以＃字符开头则被视为注释。可以在 Docker 文件中使用 RUN，CMD，FROM，EXPOSE，ENV 等指令</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210422191053.png" alt="image-20210422191046184"></p><h3 id="FROM-基础镜像"><a href="#FROM-基础镜像" class="headerlink" title="FROM:基础镜像"></a>FROM:基础镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">FROM image</span><br><span class="line">FROM image:tag</span><br><span class="line">FROM image@digest</span><br><span class="line">eg:</span><br><span class="line">FROM mysql:5.6</span><br><span class="line">ps: tag或digest是可选的，如果不使用这两个值，会使用latest版本的基础镜像 </span><br></pre></td></tr></table></figure><h3 id="MAINTAINER-维护者信息"><a href="#MAINTAINER-维护者信息" class="headerlink" title="MAINTAINER:维护者信息"></a>MAINTAINER:维护者信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式:</span><br><span class="line">MAINTAINER name</span><br><span class="line">eg:</span><br><span class="line">MAINTAINER SadnessPineapple</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN 用于在镜像容器中执行命令，有以下两种命令执行方式</span><br><span class="line">格式:</span><br><span class="line">run command</span><br><span class="line">eg:</span><br><span class="line">RUN [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]<span class="comment">#executable:可执行的命令</span></span><br><span class="line">run echo <span class="string">&quot;nameserver 114.114.114.114&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将本地文件添加到容器中(tar类型的文件会自动解压)</span><br><span class="line">格式:</span><br><span class="line">ADD src dest</span><br><span class="line">eg:</span><br><span class="line">ADD hom* &#x2F;mydir&#x2F; 将所有的文件添加到&#x2F;mydir&#x2F;下</span><br></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</span><br><span class="line">格式:</span><br><span class="line">COPY src dest</span><br><span class="line">eg:</span><br><span class="line">dest 为镜像中的绝对路径或者相对于WORKDIR的路径</span><br></pre></td></tr></table></figure><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构建容器后调用，也就是在容器启动时才进行调用，只能有一个，多个的话会被覆盖</span><br><span class="line">格式:</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">示例:</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能与CMD相似，但是不会被覆盖</span><br><span class="line">格式:</span><br><span class="line">ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">示例:</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用于为镜像添加元数据</span><br><span class="line">格式:</span><br><span class="line">LABEL &lt;key&gt;&#x3D;&lt;value&gt;</span><br><span class="line">示例:</span><br><span class="line">LABEL version&#x3D;&quot;1.0&quot; description&#x3D;&quot;这是一个 Web 服务器&quot; by&#x3D;&quot;IT 笔录&quot;</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量</span><br><span class="line">格式:</span><br><span class="line">ENV &lt;key&gt; &lt;value&gt; <span class="comment">#&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置 一个变量</span></span><br><span class="line">示例:</span><br><span class="line">    ENV myName John Doe</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定于外界交互的端口</span><br><span class="line">格式:</span><br><span class="line">EXPOSE &lt;port&gt;</span><br><span class="line">示例:</span><br><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Docker的数据持久化主要有两种方式：</span><br><span class="line">    bind mount</span><br><span class="line">    volume</span><br><span class="line">Docker的数据持久化即使数据不随着container的结束而结束，数据存在于host机器上——要么存在于host的某个指定目录中（使用bind mount），要么使用docker自己管理的volume（/var/lib/docker/volumes下）。</span><br><span class="line">格式:</span><br><span class="line">VOLUME [<span class="string">&quot;/path&quot;</span>] <span class="comment">#将容器内的某个文件挂载出来</span></span><br><span class="line">示例:</span><br><span class="line">VOLUME [<span class="string">&quot;/data&quot;</span>]</span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的。</span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">工作目录，类似于 cd 命令</span><br><span class="line">格式:</span><br><span class="line">WORKDIR /path/to/workdir</span><br><span class="line">示例：</span><br><span class="line">WORKDIR /a (这时工作目录为/a) </span><br><span class="line">WORKDIR b (这时工作目录为/a/b)</span><br><span class="line">ps：通过 WORKDIR 设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。在使用 docker run运行容器时，可以通过-w 参数覆盖构建时所设置的工作目录。</span><br></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">用于指定传递给构建运行时的变量</span><br><span class="line">构建参数和ENV的效果一样,都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history还是可以看到所有值的。</span><br><span class="line">Dockerfile中的ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build中用--build-arg&lt;参数名&gt;=&lt;值&gt;来覆盖。</span><br><span class="line">灵活的使用ARG指令，能够在不修改Dockerfile的情况下，构建出不同的镜像。</span><br><span class="line">ARG指令有生效范围，如果在FROM指令之前指定，那么只能用于FROM指令中</span><br><span class="line"></span><br><span class="line">格式:</span><br><span class="line">ARG参数名=默认值</span><br><span class="line">eg:</span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br><span class="line"></span><br><span class="line">FROM $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line">ARG DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -x ; echo $&#123;DOCKER_USERNAME&#125;</span><br></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式： </span><br><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line">eg:</span><br><span class="line">    ONBUILD ADD . &#x2F;app&#x2F;src </span><br><span class="line">    ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build --dir &#x2F;app&#x2F;src </span><br><span class="line"></span><br><span class="line">ps:当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发</span><br></pre></td></tr></table></figure><h3 id="使用dockerfile启动"><a href="#使用dockerfile启动" class="headerlink" title="使用dockerfile启动"></a>使用dockerfile启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在Dockerfile文件这个目录下执行命令</span><br><span class="line">docker build -t myubuntu:v1 .</span><br><span class="line">docker：docker命令。</span><br><span class="line"></span><br><span class="line">build：编译。</span><br><span class="line"></span><br><span class="line">-t：镜像的名字及tag，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个tag，参考docker build命令详解。</span><br><span class="line"></span><br><span class="line">myubuntu：生成镜像的名称。</span><br><span class="line"></span><br><span class="line">v1：生成镜像的版本号。</span><br><span class="line"></span><br><span class="line">.：点符号“.”代表当前</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c_id</span><br><span class="line">from_clue&#x3D;&quot;&quot;,</span><br><span class="line">up_regno&#x3D;&quot;&quot;,</span><br><span class="line">regno&#x3D;&quot;&quot;,                       </span><br><span class="line">file &#x3D; False,</span><br><span class="line">report &#x3D; False, </span><br><span class="line">release &#x3D; &quot;判断&quot;, </span><br><span class="line">remand &#x3D; False,</span><br><span class="line">write&#x3D;True,</span><br><span class="line">delete&#x3D;True,</span><br><span class="line">finish&#x3D;True</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dockerfile-构建镜像&quot;&gt;&lt;a href=&quot;#Dockerfile-构建镜像&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile 构建镜像&quot;&gt;&lt;/a&gt;Dockerfile &lt;strong&gt;构建镜像&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;​</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker安装教程</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E5%AE%89%E8%A3%85/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E5%AE%89%E8%A3%85/</id>
    <published>2021-08-15T15:32:16.249Z</published>
    <updated>2021-08-15T15:32:16.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker安装教程-centos"><a href="#docker安装教程-centos" class="headerlink" title="docker安装教程(centos)"></a>docker安装教程(centos)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>更换yum源</span><br><span class="line"><span class="comment">#里面找到你需要更换的系统版本，根据教程即可</span></span><br><span class="line">https://developer.aliyun.com/mirror/</span><br><span class="line">yum clean <span class="built_in">all</span> <span class="comment">#清除缓存</span></span><br><span class="line">yum makecache <span class="comment">#生成缓存</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>更新系统</span><br><span class="line">yum update -y --exclud=kernel*</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>安装所需的基础软件</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-<span class="number">7.</span>repo</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>将docker-ce的源换成国内阿里的</span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">ps:上述命令找不到的话先使用安装一些工具包 yum -y install yum-utils</span><br><span class="line">yum makecache fast <span class="comment">#更新缓存</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5.</span>安装docker-ce</span><br><span class="line">yum -y install docker-ce <span class="comment">#docker社区版</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>设置开机自启动并且立即启动程序</span><br><span class="line">systemctl enable --now docker </span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>检验是否启动成功</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="docker安装教程-Ubuntu"><a href="#docker安装教程-Ubuntu" class="headerlink" title="docker安装教程(Ubuntu)"></a>docker安装教程(Ubuntu)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>更新系统</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>安装基础软件</span><br><span class="line">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>安装GPG证书</span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - OK</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>写入软件源信息</span><br><span class="line">add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>更新</span><br><span class="line">apt-get -y update</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>安装docker-ce</span><br><span class="line">apt-get -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>启动</span><br><span class="line">Docker Engine - Community</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># CentOS-Base.repo</span><br><span class="line">#</span><br><span class="line"># The mirror system uses the connecting IP address of the client and the</span><br><span class="line"># update status of each mirror to pick mirrors that are updated to and</span><br><span class="line"># geographically close to the client.  You should use this for CentOS updates</span><br><span class="line"># unless you are manually picking other mirrors.</span><br><span class="line">#</span><br><span class="line"># If the mirrorlist&#x3D; does not work for you, as a fall back you can try the</span><br><span class="line"># remarked out baseurl&#x3D; line instead.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name&#x3D;CentOS-$releasever - Base</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;os</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#released updates</span><br><span class="line">[updates]</span><br><span class="line">name&#x3D;CentOS-$releasever - Updates</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;updates&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;updates</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that may be useful</span><br><span class="line">[extras]</span><br><span class="line">name&#x3D;CentOS-$releasever - Extras</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;extras&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;extras</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">#additional packages that extend functionality of existing packages</span><br><span class="line">[centosplus]</span><br><span class="line">name&#x3D;CentOS-$releasever - Plus</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos&#x2F;$releasever&#x2F;centosplus&#x2F;$basearch&#x2F;</span><br><span class="line">#mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;repo&#x3D;centosplus</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker安装教程-centos&quot;&gt;&lt;a href=&quot;#docker安装教程-centos&quot; class=&quot;headerlink&quot; title=&quot;docker安装教程(centos)&quot;&gt;&lt;/a&gt;docker安装教程(centos)&lt;/h2&gt;&lt;figure cla</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker简介</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E7%AE%80%E4%BB%8B/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E7%AE%80%E4%BB%8B/</id>
    <published>2021-08-15T15:32:16.123Z</published>
    <updated>2021-08-15T15:32:16.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h2><h3 id="docker历史简述"><a href="#docker历史简述" class="headerlink" title="docker历史简述"></a>docker历史简述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在2010年得时候，几个年轻人凑到一块开了一个公司。公司名字是dotcloud.这个公司得主要技术点就是linux得容器技术，为了方便管理这些容器。该公司内部开开发得内部工具名字就是docker。</span><br><span class="line">但是由于该公司开始得时候业务并不是很景气，但是他们又不想放弃该技术。因此他们选择在2013年将docker开源。也因此越来越多得人开始使用docker。然后发现docker得好用之处，docker也因此变得红火起来</span><br></pre></td></tr></table></figure><h3 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h3><p>docker是用go语言进行得开发，然后使用得技术是容器化。</p><p>在docker之前我们使用得技术一般是虚拟机技术</p><h3 id="容器化技术与虚拟机技术得区别"><a href="#容器化技术与虚拟机技术得区别" class="headerlink" title="容器化技术与虚拟机技术得区别"></a>容器化技术与虚拟机技术得区别</h3><p>虚拟机技术</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210602195328.jpg" alt="1622634522(1)"></p><p>容器化技术</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210602200910.jpg" alt="1622635727(1)"></p><p>由上面两图可以得知容器化技术相较于虚拟化技术，使用得是同一个计算机得内核，也正因为如此，容器化技术与虚拟机技术相比而言会小很多</p><h3 id="docker优点"><a href="#docker优点" class="headerlink" title="docker优点"></a>docker优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.应用更快速得交付和部署</span><br><span class="line">打包镜像发布测试，一键运行</span><br><span class="line">2.更便捷得升级和扩缩容</span><br><span class="line">项目打包为一个镜像，扩展 服务器a</span><br><span class="line">3.更简单得系统运维</span><br><span class="line">容器化之后，开发，测试环境高度一致</span><br><span class="line">4.更高效得计算资源利用</span><br><span class="line">是内核级别得虚拟化，可以在一个物理机上运行很多得容器实例</span><br></pre></td></tr></table></figure><h3 id="docker各个项目地址"><a href="#docker各个项目地址" class="headerlink" title="docker各个项目地址"></a>docker各个项目地址</h3><p>docker社区地址:<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>docker官网地址:<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>docker文档地址:<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker简介&quot;&gt;&lt;a href=&quot;#docker简介&quot; class=&quot;headerlink&quot; title=&quot;docker简介&quot;&gt;&lt;/a&gt;docker简介&lt;/h2&gt;&lt;h3 id=&quot;docker历史简述&quot;&gt;&lt;a href=&quot;#docker历史简述&quot; class=&quot;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像基础操作</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-15T15:32:16.027Z</published>
    <updated>2021-08-15T15:32:16.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker镜像基础操作"><a href="#docker镜像基础操作" class="headerlink" title="docker镜像基础操作"></a>docker镜像基础操作</h2><h3 id="镜像获取"><a href="#镜像获取" class="headerlink" title="镜像获取"></a>镜像获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">镜像获取</span><br><span class="line">docker pull [image_name][:image_version]</span><br><span class="line">eg:</span><br><span class="line">docker pull nginx:1.17</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看本地主机上已有的镜像的基本信息</span></span><br><span class="line">docker images</span><br><span class="line">docker images ls</span><br><span class="line">REPOSITORY   TAG     IMAGE ID      CREATED      SIZE</span><br><span class="line">镜像来源     镜像标签     镜像<span class="built_in">id</span>      镜像创建时间   镜像大小</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">-a:列出所有(包括临时文件)镜像文件</span><br><span class="line">-q:仅显示 ID 信息</span><br><span class="line">--digests=true|false：列出镜像的数字摘要值</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像详细信息，可以看到作者、id等</span></span><br><span class="line">docker inspect [REPOSITORY]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像历史,若构建信息过长，可以使用--no-trunc来输出完整信息</span></span><br><span class="line">docker history [REPOSITORY]</span><br></pre></td></tr></table></figure><h3 id="镜像添加tag"><a href="#镜像添加tag" class="headerlink" title="镜像添加tag"></a>镜像添加tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">镜像添加tag</span><br><span class="line">docker tag redis:latest myredis:latest</span><br><span class="line"></span><br><span class="line">REPOSITORY   TAG     IMAGE ID       CREATED        SIZE </span><br><span class="line">redis        latest  74d107221092   19 hours ago   104MB</span><br></pre></td></tr></table></figure><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker search [option] keyword</span><br><span class="line">option:</span><br><span class="line">-f:过滤输出内容 <span class="keyword">is</span>-official=true/false stars=<span class="number">800</span>(收藏数超过<span class="number">8000</span>)</span><br><span class="line">--limit:限制<span class="number">3</span>条</span><br><span class="line">--no-trunc:不截断输出结果,有些输出结果过长的话会被截断，添加这个可以看到完整的信息</span><br><span class="line"></span><br><span class="line">输出参数释义</span><br><span class="line">NAME         DESCRIPTION    STARS    OFFICIAL    AUTOMATED</span><br><span class="line">镜像名称       镜像描述        点赞数    是否是官方    自动构建</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [option] [name]</span><br><span class="line">docker image rm [option] [name]</span><br><span class="line">参数:</span><br><span class="line">-f:强制</span><br><span class="line"></span><br><span class="line">docker image prune [option] <span class="comment">#清理镜像</span></span><br><span class="line">-a:删除所有不用的镜像，不加的话是删除临时镜像</span><br><span class="line">-f:强制删除，没有提示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>构建镜像的方式有三种，基于容器导入、基于本地模板导入、基于dockerfile创建</p><h4 id="基于容器导入（commit）"><a href="#基于容器导入（commit）" class="headerlink" title="基于容器导入（commit）"></a>基于容器导入（commit）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit [option] [container id] [image:tag]</span><br><span class="line">eg:docker commit -m &quot;Add a file&quot; -a &quot;Alvin&quot; 820a17fe3935 centos:v1</span><br><span class="line">option:</span><br><span class="line">-a:作者信息</span><br><span class="line">-m:提交信息</span><br><span class="line">-p:提交时，暂停容器运行</span><br><span class="line"></span><br><span class="line">执行命令后会在本地生成一个基于原先容器的镜像</span><br></pre></td></tr></table></figure><h4 id="将容器导出并保存为镜像-export"><a href="#将容器导出并保存为镜像-export" class="headerlink" title="将容器导出并保存为镜像(export)"></a>将容器导出并保存为镜像(export)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker export [container id] &gt; file</span><br><span class="line">eg:</span><br><span class="line">docker export daf9c3656be3 &gt; nginx.tar</span><br><span class="line"></span><br><span class="line">ps:使用export命令导出的是个压缩包，且只保存容器当时的状态</span><br></pre></td></tr></table></figure><h4 id="从包中读取镜像-import"><a href="#从包中读取镜像-import" class="headerlink" title="从包中读取镜像(import)"></a>从包中读取镜像(import)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对应export的读取</span><br><span class="line">docker import file image:tag</span><br><span class="line">eg:</span><br><span class="line">docker import nginx.tar nginx:v1</span><br></pre></td></tr></table></figure><h4 id="将本地的镜像保存为镜像包-save"><a href="#将本地的镜像保存为镜像包-save" class="headerlink" title="将本地的镜像保存为镜像包(save)"></a>将本地的镜像保存为镜像包(save)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker save [REPOSITORY]&#x2F;[image_id] &gt; file</span><br><span class="line">eg:</span><br><span class="line">    docker save nginx &gt; nginx.tar</span><br><span class="line">    docker save 62d49f9bab67 &gt; nginx.tar</span><br><span class="line">    </span><br><span class="line">将本地的多个镜像保存为镜像包</span><br><span class="line">docker save [image] [image] &gt; file</span><br><span class="line">docker save -o file [image] [image]</span><br></pre></td></tr></table></figure><h4 id="从包中加载镜像-load"><a href="#从包中加载镜像-load" class="headerlink" title="从包中加载镜像(load)"></a>从包中加载镜像(load)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对应save的读取</span><br><span class="line">docker load &lt; file</span><br></pre></td></tr></table></figure><h4 id="save与export区别"><a href="#save与export区别" class="headerlink" title="save与export区别"></a>save与export区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export导出的是容器打包</span><br><span class="line">save 是将镜像打包成包</span><br><span class="line"></span><br><span class="line">export因为是保存的容器当时的状态，因此体积会小于save,相应的会丢失到容器的元数据和以前的历史记录</span><br><span class="line">save会完整的保存</span><br><span class="line"></span><br><span class="line">export 不能将多个容器打包</span><br><span class="line">save 可以将多个包打包</span><br><span class="line"></span><br><span class="line">export 一般用来制作基础镜像:如我们从一个 ubuntu 镜像启动一个容器，然后安 装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用， 比如作为基础的开发环境</span><br><span class="line"></span><br><span class="line">save 一般用于不能连接外网的情况下，将本地的镜像打包，给别的机器使用</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker镜像基础操作&quot;&gt;&lt;a href=&quot;#docker镜像基础操作&quot; class=&quot;headerlink&quot; title=&quot;docker镜像基础操作&quot;&gt;&lt;/a&gt;docker镜像基础操作&lt;/h2&gt;&lt;h3 id=&quot;镜像获取&quot;&gt;&lt;a href=&quot;#镜像获取&quot; cla</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像加载原理</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-15T15:32:15.999Z</published>
    <updated>2021-08-15T15:32:16.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><h3 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS(联合文件系统)"></a>UnionFS(联合文件系统)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnionFS:Union文件系统是一种分层、轻量级并且高性能得文件系统，它支持对文件系统得修改，作为一次提交来一层层得叠加，同时可以将不同目录挂载到一个虚拟文件系统下，Union文件系统是docker镜像得基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体得应用镜像。</span><br><span class="line">特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终得文件系统会包含所有底层得文件和目录</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker得镜像实际上是由一层一层得文件系统组成，这种层级得文件系统就是UnionFS</span><br><span class="line"></span><br><span class="line">bootfs(boot file system)主要包含bootloader和kernel,bootloader主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统，docker镜像得最底层就是bootfs。这一层与我们典型得linux&#x2F;unix系统是一样得，包含boot加载器和内核。当boot加载完成之后整个内核都在内存中了，此时内存得使用权由bootfs转交给内核，此时系统会卸载bootfs.</span><br><span class="line"></span><br><span class="line">rootfs(root file system),在bootfs之上。包含得就是典型Linux系统中得&#x2F;dev,&#x2F;proc,&#x2F;bin,&#x2F;etc等标准目录和文件。rootfs就是各种不同得操作系统发行版，比如Ubuntu,Centos等。</span><br><span class="line"></span><br><span class="line">docker底层直接使用得是linux得kernel(内核)，因此他的上层只需要封装简单得指令集即可，这也是为什么docker得镜像都比较小，并且启动速度快得原因</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker得镜像都是只读得，当容器启动得时候，一个新的可写层会被加载到镜像得顶部。</span><br><span class="line">这一层就是我们通常说的容器层，容器之下得都叫镜像层</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker镜像加载原理&quot;&gt;&lt;a href=&quot;#docker镜像加载原理&quot; class=&quot;headerlink&quot; title=&quot;docker镜像加载原理&quot;&gt;&lt;/a&gt;docker镜像加载原理&lt;/h2&gt;&lt;h3 id=&quot;UnionFS-联合文件系统&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker可视化工具</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</id>
    <published>2021-08-15T15:32:15.842Z</published>
    <updated>2021-08-15T15:32:16.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker可视化工具"><a href="#docker可视化工具" class="headerlink" title="docker可视化工具"></a>docker可视化工具</h2><p>portainer(先用这个)</p><p>Rancher(CI/CD再用)</p><h3 id="什么是portainer"><a href="#什么是portainer" class="headerlink" title="什么是portainer"></a>什么是portainer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">portainer就是docker得一个可视化工具，通过这个我们可以使用图形化界面去控制docker镜像</span><br><span class="line"></span><br><span class="line">启动命令:</span><br><span class="line">docker run -d -v &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot; -p 8088:9000 portainer&#x2F;portainer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker可视化工具&quot;&gt;&lt;a href=&quot;#docker可视化工具&quot; class=&quot;headerlink&quot; title=&quot;docker可视化工具&quot;&gt;&lt;/a&gt;docker可视化工具&lt;/h2&gt;&lt;p&gt;portainer(先用这个)&lt;/p&gt;
&lt;p&gt;Rancher(CI/</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker网络</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/docker%E7%BD%91%E7%BB%9C/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/docker%E7%BD%91%E7%BB%9C/</id>
    <published>2021-08-15T15:32:15.788Z</published>
    <updated>2021-08-15T15:32:16.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><p>我们每启动一个docker容器，docker就会给容器分配一个ip,我们只要安装了docker.就会有一个网卡docker0桥接模式，使用的技术是veth-pair技术</p><h3 id="什么是veth-pair"><a href="#什么是veth-pair" class="headerlink" title="什么是veth-pair"></a>什么是veth-pair</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">veth-pair（Virtual Ethernet）就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span><br><span class="line">正因为有这个特性 veth-pair 充当一个桥梁</span><br></pre></td></tr></table></figure><h3 id="docker容器网络原理图示"><a href="#docker容器网络原理图示" class="headerlink" title="docker容器网络原理图示"></a>docker容器网络原理图示</h3><p><img src="C:\Users\CSIT-04\AppData\Roaming\Typora\typora-user-images\image-20210617172700073.png" alt="image-20210617172700073"></p><p>ps:docker所有得网络都是虚拟得，虚拟得转发效率高</p><h3 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a>docker网络类型</h3><table><thead><tr><th>docker网络模型</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>host模式</td><td>–network=host</td><td>容器和宿主机共享一个网络空间(Network namespace)</td></tr><tr><td>contain模式</td><td>–network=container:ID</td><td>容器和另外一个容器共享Network namespace</td></tr><tr><td>none模式</td><td>–network=none</td><td>容器有独立的Network namespace,但是并没有进行任何的网络设置</td></tr><tr><td>bridge模式</td><td>–network=bridge</td><td>当docker进程启动，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的docker容器都会链接到这个虚拟网桥上，这也是默认的模式</td></tr></tbody></table><h3 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果启动容器的时候使用 host模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</span><br><span class="line"> 使用host模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可以使用宿主机的 端口，不需要进行 NAT，host 最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</span><br></pre></td></tr></table></figure><h3 id="contain模式"><a href="#contain模式" class="headerlink" title="contain模式"></a>contain模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信</span><br></pre></td></tr></table></figure><h3 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</span><br><span class="line">这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过--network&#x3D;none 来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</span><br></pre></td></tr></table></figure><h3 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</span><br><span class="line">从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</span><br><span class="line">bridge模式是docker的默认网络模式，不写--net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用 iptables -t nat -vnL查看。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker网络&quot;&gt;&lt;a href=&quot;#docker网络&quot; class=&quot;headerlink&quot; title=&quot;docker网络&quot;&gt;&lt;/a&gt;docker网络&lt;/h2&gt;&lt;p&gt;我们每启动一个docker容器，docker就会给容器分配一个ip,我们只要安装了docke</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker容器数据卷</title>
    <link href="https://a744740454.github.io/2021/08/15/docker/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>https://a744740454.github.io/2021/08/15/docker/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</id>
    <published>2021-08-15T15:32:15.702Z</published>
    <updated>2021-08-15T15:32:16.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>首先我们思考一个场景，你有一个容器，里面装得是mysql,然后你一不小心将这个容器删除了。那么容器中得数据还在吗？</p><p>毫无疑问，这数据就没了。而为了解决这个问题。将数据持久化保存，我们可以了解docker得一个新知识点。卷技术，也就是目录得挂载。</p><p>这个技术可以帮助我们将容器内得目录，挂载到linux上面。保证数据得持久化，并且实现了容器之间得数据共享。</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210610151207.jpg" alt="1623309115(1)"></p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><p>容器使用数据卷得方式进行绑定之后，等于进行了双向绑定，我们可以在外面进行修改操作，容器内部也会修改，同理修改容器内也会影响到容器外</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v 主机内地址:容器内地址</span><br></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><h4 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匿名挂载就是你使用-v挂载路径得时候，只写了容器内得路径，没有写容器外</span><br><span class="line">eg:</span><br><span class="line">docker run -d -P --name nginx01 -v &#x2F;etc&#x2F;nginx nginx</span><br><span class="line"></span><br><span class="line">我们可以使用下述命令查看volume得信息</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect volume 名称</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210610171721.png" alt="image-20210610171721619"></p><h4 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匿名挂载就是你使用-v挂载路径得时候，写了一个任意得名称</span><br><span class="line">eg:</span><br><span class="line">docker run -d -P --name nginx02 -v test:&#x2F;etc&#x2F;nginx nginx</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210610171731.png" alt="image-20210610171731811"></p><h4 id="如何确定是具名挂载还是匿名挂载"><a href="#如何确定是具名挂载还是匿名挂载" class="headerlink" title="如何确定是具名挂载还是匿名挂载"></a>如何确定是具名挂载还是匿名挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径 匿名挂载</span><br><span class="line">-v 名称:容器内路径 具名挂载</span><br><span class="line">-v &#x2F;路径:容器内路径 指定路径挂载</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ro:readonly <span class="comment">#只读</span></span><br><span class="line">rw:readwrite <span class="comment">#可读可写</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    docker run -d -P --name nginx02 -v test:/etc/nginx:ro nginx <span class="comment">#挂载出来得文件只能由宿主机改，r</span></span><br></pre></td></tr></table></figure><h3 id="容器之间实现数据共享"><a href="#容器之间实现数据共享" class="headerlink" title="容器之间实现数据共享"></a>容器之间实现数据共享</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现在我们有两个容器。然后需要实现两个容器内之间的数据共享。这种时候我们就可以使用下述方法</span><br><span class="line">docker run --volumes-from 主容器</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;容器数据卷&quot;&gt;&lt;a href=&quot;#容器数据卷&quot; class=&quot;headerlink&quot; title=&quot;容器数据卷&quot;&gt;&lt;/a&gt;容器数据卷&lt;/h2&gt;&lt;p&gt;首先我们思考一个场景，你有一个容器，里面装得是mysql,然后你一不小心将这个容器删除了。那么容器中得数据还在吗？&lt;</summary>
      
    
    
    
    <category term="docker" scheme="https://a744740454.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://a744740454.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>css动画基础知识</title>
    <link href="https://a744740454.github.io/2021/04/17/%E5%89%8D%E7%AB%AF/css/css%E5%8A%A8%E7%94%BB/"/>
    <id>https://a744740454.github.io/2021/04/17/%E5%89%8D%E7%AB%AF/css/css%E5%8A%A8%E7%94%BB/</id>
    <published>2021-04-16T16:02:33.623Z</published>
    <updated>2021-04-16T16:26:13.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据不同的浏览器内核，css前缀会不同，目前的css3样式只支持部分浏览器。</span><br><span class="line">1.Gecko内核 前缀为-moz- 火狐浏览器</span><br><span class="line">2.Webkit内核 前缀为-webkit- 也叫谷歌内核，chrome浏览器最先开发使用</span><br><span class="line">3.Trident内核 前缀为-ms- 也称IE内核</span><br><span class="line">4.Presto内核 前缀为-o- 目前只有opera采用</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;浏览器前缀&quot;&gt;&lt;a href=&quot;#浏览器前缀&quot; class=&quot;headerlink&quot; title=&quot;浏览器前缀&quot;&gt;&lt;/a&gt;浏览器前缀&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="css动画" scheme="https://a744740454.github.io/categories/css%E5%8A%A8%E7%94%BB/"/>
    
    
    <category term="css动画" scheme="https://a744740454.github.io/tags/css%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq交换机</title>
    <link href="https://a744740454.github.io/2021/04/16/rabbitmq/rabbitmq%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
    <id>https://a744740454.github.io/2021/04/16/rabbitmq/rabbitmq%E4%BA%A4%E6%8D%A2%E6%9C%BA/</id>
    <published>2021-04-16T15:46:56.780Z</published>
    <updated>2021-04-16T15:50:26.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><h3 id="什么是AMQP"><a href="#什么是AMQP" class="headerlink" title="什么是AMQP"></a>什么是AMQP</h3><p>amqp（高级消息队列协议）是一个协议，rabbitmq就是完全基于这个协议去实现的</p><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210407145149.jpg" alt="v2-95679b747c214fcc1b30b5592177acb1_720w"></p><h3 id="amqp协议名词介绍"><a href="#amqp协议名词介绍" class="headerlink" title="amqp协议名词介绍"></a>amqp协议名词介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Producer：消息生产者，即投递消息的程序。</span><br><span class="line">Broker：消息队列服务器实体。</span><br><span class="line">Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</span><br><span class="line">Binding：绑定，它的作用就是把 Exchange 和 Queue 按照路由规则绑定起来。</span><br><span class="line">Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</span><br><span class="line">Consumer：消息消费者，即接受消息的程序。</span><br></pre></td></tr></table></figure><h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>那么为什么我们需要 Exchange 而不是直接将消息发送至队列呢？</p><p>AMQP 协议中的核心思想就是生产者和消费者的解耦，生产者从不直接将消息发送给队列。生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。先由 Exchange 来接收，然后 Exchange 按照特定的策略转发到 Queue 进行存储。Exchange 就类似于一个交换机，将各个消息分发到相应的队列中。</p><p>s<img src="https://gitee.com/a744740454/mypic/raw/master/img/20210407145057.jpg" alt="v2-a8594e4f7fec1495e692bdd1dc152d19_720w">s</p><p>exchange常用的三种类型有fanout、Direct、Topic</p><h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210407170755.jpg" alt="v2-7bb89836159c987975f6cde0b9ed7003_720w"></h4><p>Fanout Exchange 会忽略 RoutingKey 的设置，直接将 Message 广播到所有绑定的 Queue 中。</p><h4 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h4><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210407170950.jpg" alt="v2-c439643980a67bade215dc99a694c69d_720w"></p><p>Direct Exchange 是 RabbitMQ 默认的 Exchange，完全根据 RoutingKey 来路由消息。设置 Exchange 和 Queue 的 Binding 时需指定 RoutingKey（一般为 Queue Name），发消息时也指定一样的 RoutingKey，消息就会被路由到对应的Queue</p><h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p><img src="https://gitee.com/a744740454/mypic/raw/master/img/20210407171127.jpg" alt="v2-c735dc7d3e0ea74acc7f933abeaa40b7_720w"></p><p>Topic Exchange 和 Direct Exchange 类似，也需要通过 RoutingKey 来路由消息，区别在于Direct Exchange 对 RoutingKey 是精确匹配，而 Topic Exchange 支持模糊匹配。分别支持<code>*</code>和<code>#</code>通配符，<code>*</code>表示匹配一个单词，<code>#</code>则表示匹配没有或者多个单词。</p><h3 id="两种特殊的-Exchange"><a href="#两种特殊的-Exchange" class="headerlink" title="两种特殊的 Exchange"></a>两种特殊的 Exchange</h3><h4 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h4><p>Headers Exchange 会忽略 RoutingKey 而根据消息中的 Headers 和创建绑定关系时指定的 Arguments 来匹配决定路由到哪些 Queue。</p><p>Headers Exchange 的性能比较差，而且 Direct Exchange 完全可以代替它，所以不建议使用。</p><h4 id="Default-Exchange"><a href="#Default-Exchange" class="headerlink" title="Default Exchange"></a>Default Exchange</h4><p>Default Exchange 是一种特殊的 Direct Exchange。当你手动创建一个队列时，后台会自动将这个队列绑定到一个名称为空的 Direct Exchange 上，绑定 RoutingKey 与队列名称相同。有了这个默认的交换机和绑定，使我们只关心队列这一层即可，这个比较适合做一些简单的应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Exchange&quot;&gt;&lt;a href=&quot;#Exchange&quot; class=&quot;headerlink&quot; title=&quot;Exchange&quot;&gt;&lt;/a&gt;Exchange&lt;/h2&gt;&lt;h3 id=&quot;什么是AMQP&quot;&gt;&lt;a href=&quot;#什么是AMQP&quot; class=&quot;header</summary>
      
    
    
    
    <category term="rabbitmq" scheme="https://a744740454.github.io/categories/rabbitmq/"/>
    
    
    <category term="rabbitmq" scheme="https://a744740454.github.io/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>celery参数详解</title>
    <link href="https://a744740454.github.io/2021/04/16/celery/celery%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://a744740454.github.io/2021/04/16/celery/celery%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-16T15:46:54.720Z</published>
    <updated>2021-04-16T15:48:13.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="celery指令详解"><a href="#celery指令详解" class="headerlink" title="celery指令详解"></a>celery指令详解</h2><h3 id="全局指令"><a href="#全局指令" class="headerlink" title="全局指令"></a>全局指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">全局指令:</span><br><span class="line">-A APP,--app celery对象</span><br><span class="line">-b BROKER,--broker broker位置</span><br><span class="line">--result-backend backend位置</span><br><span class="line">--loader LOADER</span><br><span class="line">--config CONFIG</span><br><span class="line">--workdir WORKDIR     Optional directory to change to after detaching.</span><br><span class="line">--no-color, -C</span><br><span class="line">--quiet, -q</span><br></pre></td></tr></table></figure><h3 id="worker指令"><a href="#worker指令" class="headerlink" title="worker指令"></a>worker指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">worker指令:</span><br><span class="line">  -n HOSTNAME, --hostname HOSTNAME</span><br><span class="line">  设置worker的hostname</span><br><span class="line">  </span><br><span class="line">                        Set custom hostname (e.g., &#39;w1@%h&#39;). Expands: %h</span><br><span class="line">                        (hostname), %n (name) and %d, (domain).                      </span><br><span class="line">  -D, --detach          启动worker作为后台进程</span><br><span class="line">  </span><br><span class="line">  -S STATEDB, --statedb STATEDB</span><br><span class="line">                        Path to the state database. The extension &#39;.db&#39; may be</span><br><span class="line">                        appended to the filename. Default: None</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">  日志记录的级别,可以选择DEBUG, INFO, WARNING,</span><br><span class="line">                        ERROR, CRITICAL, or FATAL.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  -O OPTIMIZATION</span><br><span class="line">  --prefetch-multiplier PREFETCH_MULTIPLIER</span><br><span class="line">                        Set custom prefetch multiplier value for this worker</span><br><span class="line">                        instance.</span><br></pre></td></tr></table></figure><h3 id="Pool-指令"><a href="#Pool-指令" class="headerlink" title="Pool 指令"></a>Pool 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pool 指令:</span><br><span class="line">  -c CONCURRENCY, --concurrency CONCURRENCY</span><br><span class="line">处理队列的子进程数。默认值是电脑系统可用的cpu数量</span><br><span class="line"></span><br><span class="line">  -P POOL, --pool POOL  实现池的方式: prefork (default), eventlet,gevent or solo.</span><br><span class="line">  </span><br><span class="line">  -E, --task-events, --events</span><br><span class="line">                        Send task-related events that can be captured by</span><br><span class="line">                        monitors like celery events, celerymon, and others.</span><br><span class="line">                        </span><br><span class="line">  --time-limit TIME_LIMIT</span><br><span class="line">                        为任务设置一个超时时间,时间到了会直接杀死task启动另外一个task</span><br><span class="line">                        </span><br><span class="line">  --soft-time-limit SOFT_TIME_LIMIT</span><br><span class="line">                        为任务设置一个超时时间，时间到了会抛出异常，并结束task</span><br><span class="line">                        </span><br><span class="line">  --max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                        每次可以执行的最大的任务数</span><br><span class="line">                        </span><br><span class="line">  --max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                        子进程最大能占据的内存数，当一个任务导致这个进程超过限制后，任务会被完成，然后进程会被替换</span><br><span class="line">                        默认没有限制</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Queue-指令"><a href="#Queue-指令" class="headerlink" title="Queue 指令"></a>Queue 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Queue 指令:</span><br><span class="line">  --purge, --discard    </span><br><span class="line">  在守护进程启动之前将清除所有等待的任务，所有在消息队列上的任务都会被删除</span><br><span class="line">                        </span><br><span class="line">  --queues QUEUES, -Q QUEUES</span><br><span class="line">  要为这个worker启用的队列，使用逗号进行分割，默认都启用</span><br><span class="line">                        Example: -Q video,image</span><br><span class="line">                        </span><br><span class="line">  --exclude-queues EXCLUDE_QUEUES, -X EXCLUDE_QUEUES</span><br><span class="line">                        要为这个worker禁用的队列，使用逗号进行分割</span><br><span class="line">                        enabled. Example: -X video,image.</span><br><span class="line">                        </span><br><span class="line">  --include INCLUDE, -I INCLUDE</span><br><span class="line">                        用逗号分割要导入的模块列表</span><br><span class="line">                        Example: -I foo.tasks,bar.tasks</span><br></pre></td></tr></table></figure><h3 id="Features指令"><a href="#Features指令" class="headerlink" title="Features指令"></a>Features指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Features 指令:</span><br><span class="line">  --without-gossip      不会订阅其他的workers events.</span><br><span class="line">  --without-mingle      不会在启动的时候和其他worker同步</span><br><span class="line">  --without-heartbeat   不发送heartbeats.</span><br><span class="line">  --heartbeat-interval HEARTBEAT_INTERVAL</span><br><span class="line">                        发送worker heartbeat的时间间隔</span><br><span class="line">  --autoscale AUTOSCALE</span><br><span class="line">                       通过提供max_concurrency和min_concurrency来启用自动伸缩</span><br><span class="line">                       Example:: --autoscale&#x3D;10,3 (always keep 3 processes, but grow to 10 if necessary)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Daemonization-指令"><a href="#Daemonization-指令" class="headerlink" title="Daemonization 指令"></a>Daemonization 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Daemonization 指令:</span><br><span class="line">  -f LOGFILE, --logfile LOGFILE</span><br><span class="line">                        日志文件的路径,不指定的话输出到stderr</span><br><span class="line">                        </span><br><span class="line">  --pidfile PIDFILE     用于存储进程的文件，如果文件已经存在并且进程还存活，就不会启动这个进程</span><br><span class="line">  </span><br><span class="line">  --uid UID             User id, or user name of the user to run as after</span><br><span class="line">                        detaching.</span><br><span class="line">                        </span><br><span class="line">  --gid GID             Group id, or group name of the main group to change to</span><br><span class="line">                        after detaching.</span><br><span class="line">                        </span><br><span class="line">  --umask UMASK         Effective umask(1) (in octal) of the process after</span><br><span class="line">                        detaching. Inherits the umask(1) of the parent process</span><br><span class="line">                        by default.</span><br><span class="line">                        </span><br><span class="line">  --executable EXECUTABLE</span><br><span class="line">                        Executable to use for the detached process.</span><br></pre></td></tr></table></figure><h3 id="Embedded-Beat-指令"><a href="#Embedded-Beat-指令" class="headerlink" title="Embedded Beat 指令"></a>Embedded Beat 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Embedded Beat 指令:</span><br><span class="line">  -B, --beat          用于运行celery的周期任务，在服务中一次只能有一个beat，在生产环境中需要将celery beat分开 </span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">  -s SCHEDULE_FILENAME, --schedule-filename SCHEDULE_FILENAME, --schedule SCHEDULE_FILENAME</span><br><span class="line">                        Path to the schedule database if running with the -B</span><br><span class="line">                        option. Defaults to celerybeat-schedule. The extension</span><br><span class="line">                        &quot;.db&quot; may be appended to the filename. Apply</span><br><span class="line">                        optimization profile. Supported: default, fair</span><br><span class="line">                        </span><br><span class="line">  --scheduler SCHEDULER</span><br><span class="line">  指定sehedule的类，默认是celery.beat.PersistentScheduler</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="celery-–poll参数详解"><a href="#celery-–poll参数详解" class="headerlink" title="celery –poll参数详解"></a>celery –poll参数详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. prefork（默认）：worker会开启多个进程来执行具体的任务实例（task instance），适合于CPU密集型应用；这会开启一个worker主进程，和一组工作进程（如果并行度设置为2，当使用ps -ef | grep celery的时候，会看到3个进程，多出来的一个就是主进程）</span><br><span class="line"></span><br><span class="line">2. eventlet：适用于I&#x2F;O密集型应用；底层使用epoll或者libevent来驱动多路复用。要注意不要在这样的worker中运行CPU密集型的任务实例。</span><br><span class="line"></span><br><span class="line">3. gevent：类似于eventlet，基于libev或者libuv事件循环。</span><br><span class="line"></span><br><span class="line">4. solo：接收控制指令同运行任务实例在同一个进程里执行，如果任务实例执行时间较长会阻塞控制指令请求的响应，客户端需要适度增加超时时间设置。（一般不使用）</span><br></pre></td></tr></table></figure><h3 id="celery中的-task-time-limit-和-task-soft-time-limit"><a href="#celery中的-task-time-limit-和-task-soft-time-limit" class="headerlink" title="celery中的 task_time_limit 和 task_soft_time_limit"></a>celery中的 task_time_limit 和 task_soft_time_limit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task_time_limit：</span><br><span class="line">hard模式，如果配置了10s， 10s内 task 没有执行结束，则处理这个task会被杀掉，并继续执行其他新的 task</span><br><span class="line"></span><br><span class="line">task_soft_time_limit：</span><br><span class="line">soft 模式，如果配置了10s， 10s内 task 没有执行结束，可以在 task 内捕获这个异常，并处理。也可以在全局处理，进行重试或扔死信队列等操作。</span><br><span class="line">比如，在 task 中捕获异常：</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;celery指令详解&quot;&gt;&lt;a href=&quot;#celery指令详解&quot; class=&quot;headerlink&quot; title=&quot;celery指令详解&quot;&gt;&lt;/a&gt;celery指令详解&lt;/h2&gt;&lt;h3 id=&quot;全局指令&quot;&gt;&lt;a href=&quot;#全局指令&quot; class=&quot;head</summary>
      
    
    
    
    <category term="celery学习" scheme="https://a744740454.github.io/categories/celery%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="celery" scheme="https://a744740454.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>mongodb CURD操作</title>
    <link href="https://a744740454.github.io/2021/03/15/mongodb/mongodbCURD/"/>
    <id>https://a744740454.github.io/2021/03/15/mongodb/mongodbCURD/</id>
    <published>2021-03-15T14:57:27.010Z</published>
    <updated>2021-03-15T15:16:45.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mongodb-CURD操作"><a href="#mongodb-CURD操作" class="headerlink" title="mongodb CURD操作"></a>mongodb CURD操作</h2><h3 id="mongodb数据库操作"><a href="#mongodb数据库操作" class="headerlink" title="mongodb数据库操作"></a>mongodb数据库操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、增</span></span><br><span class="line">use 数据库名 <span class="comment">#如果数据库不存在，则创建数据库，否则切换到指定数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、查</span></span><br><span class="line">show dbs <span class="comment">#查看所有</span></span><br><span class="line"></span><br><span class="line">若直接创建完数据库使用这个命令，你是看不到的，要显示它，我们需要向config数据库插入一些数据。</span><br><span class="line">db.table1.insert(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、删</span></span><br><span class="line">use 数据库名 <span class="comment">#先切换到要删的库下</span></span><br><span class="line">db.dropDatabase() <span class="comment">#删除当前库</span></span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">db代表当前库</span><br></pre></td></tr></table></figure><h3 id="mongodb集合操作-表"><a href="#mongodb集合操作-表" class="headerlink" title="mongodb集合操作(表)"></a>mongodb集合操作(表)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、增</span></span><br><span class="line">当第一个文档(数据)插入时，集合就会被创建</span><br><span class="line">use database1</span><br><span class="line">db.table1.insert(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;) <span class="comment">#自动创建集合并且插入数据</span></span><br><span class="line"><span class="comment">#注意 db.user和db.user.info是两个表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、查</span></span><br><span class="line">show collections</span><br><span class="line">show tables</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、删</span></span><br><span class="line">db.集合名.drop()</span><br></pre></td></tr></table></figure><h3 id="mongodb文档操作"><a href="#mongodb文档操作" class="headerlink" title="mongodb文档操作"></a>mongodb文档操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增单条</span></span><br><span class="line"><span class="comment">#新建数据</span></span><br><span class="line">user0=&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;lqz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>:[<span class="string">&#x27;music&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;dancing&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;addr&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;country&#x27;</span>:<span class="string">&#x27;China&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;BJ&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.test.insert(user0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加多条</span></span><br><span class="line"><span class="comment">#新建多条数据</span></span><br><span class="line">db.user.insertMany([user1,user2,user3,user4,user5])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有则覆盖，没则新增</span></span><br><span class="line">db.user.save(&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lqz&quot;</span>&#125;)</span><br><span class="line">db.user.save(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lqz&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>比较运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较运算</span></span><br><span class="line"><span class="comment"># SQL：=,!=,&gt;,&lt;,&gt;=,&lt;=</span></span><br><span class="line"><span class="comment"># MongoDB：&#123;key:value&#125;代表什么等于什么,&quot;$ne&quot;,&quot;$gt&quot;,&quot;$lt&quot;,&quot;gte&quot;,&quot;lte&quot;,其中&quot;$ne&quot;能用于所有数据类型</span></span><br><span class="line">db.user.find().pretty()  <span class="comment"># 以json格式显示，了解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1、select * from db1.user where name = &quot;lqz1&quot;;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lqz1&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、select * from db1.user where name != &quot;lqz2&quot;;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;name&#x27;</span>:&#123;<span class="string">&quot;$ne&quot;</span>:<span class="string">&#x27;lqz2&#x27;</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、select * from db1.user where id &gt; 2;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;_id&#x27;</span>:&#123;<span class="string">&#x27;$gt&#x27;</span>:<span class="number">2</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、select * from db1.user where id &lt; 3;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;_id&#x27;</span>:&#123;<span class="string">&#x27;$lt&#x27;</span>:<span class="number">3</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、select * from db1.user where id &gt;= 2;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&quot;_id&quot;</span>:&#123;<span class="string">&quot;$gte&quot;</span>:<span class="number">2</span>,&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6、select * from db1.user where id &lt;= 2;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&quot;_id&quot;</span>:&#123;<span class="string">&quot;$lte&quot;</span>:<span class="number">2</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>逻辑运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#逻辑运算</span></span><br><span class="line"><span class="comment"># SQL：and，or，not ，mod（取余数）</span></span><br><span class="line"><span class="comment"># MongoDB：字典中逗号分隔的多个条件是and关系，&quot;$or&quot;的条件放到[]内,&quot;$not&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1、select * from db1.user where id &gt;= 2 and id &lt; 4;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;_id&#x27;</span>:&#123;<span class="string">&quot;$gte&quot;</span>:<span class="number">2</span>,<span class="string">&quot;$lt&quot;</span>:<span class="number">4</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、select * from db1.user where id &gt;= 2 and age &lt; 40;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&quot;_id&quot;</span>:&#123;<span class="string">&quot;$gte&quot;</span>:<span class="number">2</span>&#125;,<span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;$lt&quot;</span>:<span class="number">40</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、select * from db1.user where id &gt;= 5 or name = &quot;lqz&quot;;</span></span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    <span class="string">&quot;$or&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&#x27;_id&#x27;</span>:&#123;<span class="string">&quot;$gte&quot;</span>:<span class="number">5</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lqz&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、select * from db1.user where id % 2=1;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;_id&#x27;</span>:&#123;<span class="string">&quot;$mod&quot;</span>:[<span class="number">2</span>,<span class="number">1</span>]&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、上题，取反</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;_id&#x27;</span>:&#123;<span class="string">&quot;$not&quot;</span>:&#123;<span class="string">&quot;$mod&quot;</span>:[<span class="number">2</span>,<span class="number">1</span>]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>成员运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 成员运算</span></span><br><span class="line"><span class="comment"># SQL：in，not in</span></span><br><span class="line"><span class="comment"># MongoDB：&quot;$in&quot;,&quot;$nin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1、select * from db1.user where age in (20,30,31);</span></span><br><span class="line">db.user.find(&#123;<span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;$in&quot;</span>:[<span class="number">20</span>,<span class="number">30</span>,<span class="number">31</span>]&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、select * from db1.user where name not in (&#x27;lqz1&#x27;,&#x27;lqz2&#x27;);</span></span><br><span class="line">db.user.find(&#123;<span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;$nin&quot;</span>:[<span class="string">&#x27;lqz1&#x27;</span>,<span class="string">&#x27;lqz2&#x27;</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>正则匹配</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SQL: regexp 正则</span></span><br><span class="line"><span class="comment"># MongoDB: /正则表达/i</span></span><br><span class="line"><span class="comment">#1、select * from db1.user where name regexp &#x27;^l&#x27;;</span></span><br><span class="line"><span class="comment"># 查询名字以l开头的人</span></span><br><span class="line">db.user.find(&#123;&quot;name&quot;:/.*?/&#125;)</span><br><span class="line">db.user.find(&#123;<span class="string">&quot;name&quot;</span>:/^l/&#125;)</span><br><span class="line"><span class="comment"># 查询名字以l开头，以1结尾的所有数据</span></span><br><span class="line">db.user.find(&#123;&quot;name&quot;:/^l.*?1$/&#125;)</span><br></pre></td></tr></table></figure><p>取指定字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、select name,age from db1.user where id=3;</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;_id&#x27;</span>:<span class="number">3</span>&#125;,&#123;<span class="string">&#x27;_id&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;name&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment"># 0表示不显示，1表示显示</span></span><br></pre></td></tr></table></figure><p>查询数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、查看有dancing爱好的人</span></span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;hobbies&#x27;</span>:<span class="string">&#x27;dancing&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、查看既有dancing爱好又有tea爱好的人</span></span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;$all&quot;</span>:[<span class="string">&#x27;dancing&#x27;</span>,<span class="string">&#x27;tea&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、查看第4个爱好为tea的人</span></span><br><span class="line">db.user.find(&#123;<span class="string">&quot;hobbies.3&quot;</span>:<span class="string">&#x27;tea&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、查看所有人最后两个爱好(注意没有hobbies字段的也会被查出)（本质用的是取指定字段，所以要放在后面的字典中）</span></span><br><span class="line">db.user.find(&#123;&#125;,&#123;<span class="string">&#x27;hobbies&#x27;</span>:&#123;<span class="string">&quot;$slice&quot;</span>:-<span class="number">2</span>&#125;,<span class="string">&quot;age&quot;</span>:<span class="number">0</span>,<span class="string">&quot;_id&quot;</span>:<span class="number">0</span>,<span class="string">&quot;name&quot;</span>:<span class="number">0</span>,<span class="string">&quot;addr&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5、查看所有人的第2个到第3个爱好</span></span><br><span class="line">db.user.find(&#123;&#125;,&#123;<span class="string">&#x27;hobbies&#x27;</span>:&#123;<span class="string">&quot;$slice&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;,<span class="string">&quot;age&quot;</span>:<span class="number">0</span>,<span class="string">&quot;_id&quot;</span>:<span class="number">0</span>,<span class="string">&quot;name&quot;</span>:<span class="number">0</span>,<span class="string">&quot;addr&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.blog.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span> : <span class="string">&quot;alex意外死亡的真相&quot;</span>,</span><br><span class="line">        <span class="string">&quot;comments&quot;</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;name&quot;</span> : <span class="string">&quot;egon&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;content&quot;</span> : <span class="string">&quot;alex是谁？？？&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;thumb&quot;</span> : <span class="number">200</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wxx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;content&quot;</span> : <span class="string">&quot;我去，真的假的&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;thumb&quot;</span> : <span class="number">300</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;name&quot;</span> : <span class="string">&quot;yxx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;content&quot;</span> : <span class="string">&quot;吃喝嫖赌抽，欠下两个亿&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;thumb&quot;</span> : <span class="number">40</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;name&quot;</span> : <span class="string">&quot;egon&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;content&quot;</span> : <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;thumb&quot;</span> : <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">db.blog.find(&#123;&#125;,&#123;<span class="string">&#x27;comments&#x27;</span>:&#123;<span class="string">&quot;$slice&quot;</span>:-<span class="number">2</span>&#125;&#125;).pretty() <span class="comment">#查询最后两个</span></span><br><span class="line">db.blog.find(&#123;&#125;,&#123;<span class="string">&#x27;comments&#x27;</span>:&#123;<span class="string">&quot;$slice&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;&#125;).pretty() <span class="comment">#查询1到2</span></span><br></pre></td></tr></table></figure><p>排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排序:--1代表升序，-1代表降序</span></span><br><span class="line">db.user.find().sort(&#123;<span class="string">&quot;name&quot;</span>:<span class="number">1</span>,&#125;)</span><br><span class="line">db.user.find().sort(&#123;<span class="string">&quot;age&quot;</span>:-<span class="number">1</span>,<span class="string">&#x27;_id&#x27;</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>分页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分页:--limit代表取多少个document，skip代表跳过前多少个document。 </span></span><br><span class="line"><span class="comment"># limit中表示一页显示的条数，skip(页码数*一页显示的条数)</span></span><br><span class="line">db.user.find().sort(&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">1</span>&#125;).limit(<span class="number">1</span>).skip(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表关联</span></span><br><span class="line">user &#123;_id:<span class="number">1</span>,name:lqz,age:<span class="number">18</span>&#125;   一个人写多篇文章</span><br><span class="line">article ----》子查询</span><br><span class="line">&#123;<span class="string">&#x27;userid&#x27;</span>:<span class="number">1</span>,article:红楼梦&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;userid&#x27;</span>:<span class="number">1</span>,article:西游记&#125;</span><br></pre></td></tr></table></figure><p>获取数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数量</span></span><br><span class="line">db.user.count(&#123;<span class="string">&#x27;age&#x27;</span>:&#123;<span class="string">&quot;$gt&quot;</span>:<span class="number">30</span>&#125;&#125;) </span><br><span class="line">--或者</span><br><span class="line">db.user.find(&#123;<span class="string">&#x27;age&#x27;</span>:&#123;<span class="string">&quot;$gt&quot;</span>:<span class="number">30</span>&#125;&#125;).count()</span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、&#123;&#x27;key&#x27;:null&#125; 匹配key的值为null或者没有这个key</span></span><br><span class="line">db.t2.insert(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">111</span>&#125;)</span><br><span class="line">db.t2.insert(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">20</span>&#125;)</span><br><span class="line">db.t2.insert(&#123;<span class="string">&#x27;b&#x27;</span>:null&#125;)</span><br><span class="line"></span><br><span class="line">&gt; db.t2.find(&#123;<span class="string">&quot;b&quot;</span>:null&#125;)</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a5cc2a7c1b4645aad959e5a&quot;</span>), <span class="string">&quot;a&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a5cc2a8c1b4645aad959e5b&quot;</span>), <span class="string">&quot;b&quot;</span> : null &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、查找所有</span></span><br><span class="line">db.user.find() <span class="comment">#等同于db.user.find(&#123;&#125;)</span></span><br><span class="line">db.user.find().pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、查找一个，与find用法一致，只是只取匹配成功的第一个</span></span><br><span class="line">db.user.findOne(&#123;<span class="string">&quot;_id&quot;</span>:&#123;<span class="string">&quot;$gt&quot;</span>:<span class="number">3</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mongodb-CURD操作&quot;&gt;&lt;a href=&quot;#mongodb-CURD操作&quot; class=&quot;headerlink&quot; title=&quot;mongodb CURD操作&quot;&gt;&lt;/a&gt;mongodb CURD操作&lt;/h2&gt;&lt;h3 id=&quot;mongodb数据库操作&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="mongodb" scheme="https://a744740454.github.io/categories/mongodb/"/>
    
    
    <category term="mongodb" scheme="https://a744740454.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Flask-PyMongo简单使用</title>
    <link href="https://a744740454.github.io/2021/03/15/flask/Flask-PyMongo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://a744740454.github.io/2021/03/15/flask/Flask-PyMongo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-15T14:34:40.012Z</published>
    <updated>2021-03-15T15:17:14.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask-PyMongo-CRUD操作"><a href="#Flask-PyMongo-CRUD操作" class="headerlink" title="Flask-PyMongo CRUD操作"></a>Flask-PyMongo CRUD操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Flask-PyMongo-CRUD操作&quot;&gt;&lt;a href=&quot;#Flask-PyMongo-CRUD操作&quot; class=&quot;headerlink&quot; title=&quot;Flask-PyMongo CRUD操作&quot;&gt;&lt;/a&gt;Flask-PyMongo CRUD操作&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="flask" scheme="https://a744740454.github.io/categories/flask/"/>
    
    
    <category term="flask" scheme="https://a744740454.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>将mongo中的数据转换成json格式</title>
    <link href="https://a744740454.github.io/2021/03/15/flask/%E5%B0%86mongo%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90json%E6%A0%BC%E5%BC%8F/"/>
    <id>https://a744740454.github.io/2021/03/15/flask/%E5%B0%86mongo%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E6%88%90json%E6%A0%BC%E5%BC%8F/</id>
    <published>2021-03-15T14:31:31.311Z</published>
    <updated>2021-03-15T14:31:31.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将mongo中的数据转换成json格式"><a href="#将mongo中的数据转换成json格式" class="headerlink" title="将mongo中的数据转换成json格式"></a>将mongo中的数据转换成json格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个是将mongo Document对象转换成json的编码器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoEncoder</span>(<span class="params">JSONEncoder</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span>(<span class="params">self, o</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换日期</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(o, (datetime, date)):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换Document</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(o, BaseDocument):</span><br><span class="line">            <span class="keyword">return</span> o.to_mongo()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换id</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(o, ObjectId):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(o)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JSONEncoder.default(self, o)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在蓝图上添加mongo解码器.  jsonify会自动将Document对象转成json</span></span><br><span class="line">bp = Blueprint(<span class="string">&quot;article&quot;</span>, __name__, url_prefix=<span class="string">&quot;/article&quot;</span>)</span><br><span class="line">bp.json_encoder = MongoEncoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&quot;/&lt;id&gt;/&quot;</span>, methods=(<span class="params"><span class="string">&quot;GET&quot;</span>,</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article</span>(<span class="params"><span class="built_in">id</span>: <span class="built_in">str</span></span>):</span></span><br><span class="line">    instance = Article.objects.get_or_404(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: instance</span><br><span class="line">    &#125;)      </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将mongo中的数据转换成json格式&quot;&gt;&lt;a href=&quot;#将mongo中的数据转换成json格式&quot; class=&quot;headerlink&quot; title=&quot;将mongo中的数据转换成json格式&quot;&gt;&lt;/a&gt;将mongo中的数据转换成json格式&lt;/h2&gt;&lt;figu</summary>
      
    
    
    
    <category term="flask" scheme="https://a744740454.github.io/categories/flask/"/>
    
    
    <category term="flask" scheme="https://a744740454.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask使用mongodb</title>
    <link href="https://a744740454.github.io/2021/03/15/flask/flask%E4%B8%AD%E4%BD%BF%E7%94%A8MongoDB/"/>
    <id>https://a744740454.github.io/2021/03/15/flask/flask%E4%B8%AD%E4%BD%BF%E7%94%A8MongoDB/</id>
    <published>2021-03-15T13:53:16.523Z</published>
    <updated>2021-03-15T14:30:25.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask连接mongodb"><a href="#flask连接mongodb" class="headerlink" title="flask连接mongodb"></a>flask连接mongodb</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">经过一番资料的查找，我发现flask连接mongodb有三种方式</span><br><span class="line"><span class="number">1.</span>PyMongo <span class="comment">#官方提供的最基本的</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>flask_pymongo <span class="comment">#在pymongo上封装的</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Flask-MongoEngine <span class="comment">#类似于django orm的</span></span><br><span class="line"></span><br><span class="line">我这里的业务需求的话只需要使用第二种即可</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line"><span class="number">1.</span>安装flask_pymongo</span><br><span class="line">pip install Flask-PyMongo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>获得mongo对象</span><br><span class="line"><span class="keyword">from</span> flask_pymongo <span class="keyword">import</span> PyMongo</span><br><span class="line">app.config[<span class="string">&quot;MONGO_URI&quot;</span>] = <span class="string">&quot;mongodb://username:password@host:port/myDatabase&quot;</span></span><br><span class="line">mongo = PyMongo(app)</span><br><span class="line"></span><br><span class="line">ps:上述的连接可能会报出认证错误，解决问题的方法如下</span><br><span class="line">app.config[<span class="string">&quot;MONGO_URI&quot;</span>] = <span class="string">&quot;mongodb://username:password@host:port/myDatabase?authSource=admin&quot;</span>    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;flask连接mongodb&quot;&gt;&lt;a href=&quot;#flask连接mongodb&quot; class=&quot;headerlink&quot; title=&quot;flask连接mongodb&quot;&gt;&lt;/a&gt;flask连接mongodb&lt;/h2&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="flask" scheme="https://a744740454.github.io/categories/flask/"/>
    
    
    <category term="flask" scheme="https://a744740454.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://a744740454.github.io/2021/03/03/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://a744740454.github.io/2021/03/03/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-03T04:01:47.734Z</published>
    <updated>2021-03-03T04:01:59.474Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://a744740454.github.io/2021/03/03/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://a744740454.github.io/2021/03/03/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-03T04:01:47.734Z</published>
    <updated>2021-03-03T04:01:47.734Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
